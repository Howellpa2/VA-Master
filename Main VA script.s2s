'Debug("");
var PCSprotocol$;
var resultViewH%;
var MwaveResultView%;
var highPassFilter[511];
var fileMwave% := 0;
var subjectID$;
var doAutoControl% := 1;
var currentTrigTime:=0; 'originally set to -1
var updateNecessary%:=0; 'originally set to 0
var stimcount% := 0;
var TMSlastCommandTime := -1;
var lastStimOutput% := -1;
var curChan% :=1;
var BicepEMGchan% := 1;
var ManualpVAThresh%:=1;
var cScale,cOffset;
var Protocol%:= 1;
var MwaveProtocol%:= 1;
var pVAProtocol%:= 2;
var pVAdata%:= -1;
var cVAdata%:=-1;
var data%:=-1;
var pVAThreshdata%:= -1;
var MwaveThreshdata%:=-1;
var MwaveBarGraph%:=-1;
var ForceFeedbackBarGraph%:=-1;
var level;
var s$:="something";
var lTime;
var FeedbackTime;
var pVAButtonDisable% := 0;
var prevPeakToPeak:= -2;
var curPeakToPeak:=0;
var newestEvent;
var TrialCount%:=0;
var MVCstartTime[3];
var MVCendTime[3];
var TrialMVC[1];
var TrialrmsMzIn, avgRMSin;
var RMSIn[3];
var getTwitch%:=0;
var counter%:=0;
var getRestingTwitch%:=0;
var LastStimTime;
var cVAprotocol$;
var updateMEP%;
var numStim%;
var TwitchTrial%;
var VA_Arr[10];
var MVCtwitchArr[10];
var RestingTwitchArr[10];
var MVCtwitchTimeArr[10];
var MVCtwitchAmp;
var MVCtwitchPP;
var RestingTwitchIndex%;
var RestingTwitch;
var RestingTwitchPP;
var doBestPest%;
var rMT%;
var fileRMTNo% := 0;
var curStimOutput%;
var FirstcVAProtocol$;
var SecondcVAProtocol$;
var ThirdcVAProtocol$;
var ArmPosture$;
var ReflexInterval$;
var ISI$;
var TMSintensityA;
var TMSintensityB;
var ISI;
var SubProtocol$;
var NormalizedMEP;
var NormedMEPArr[6];
var PreMEParray[6];
var MEPTimeArr[6];
var bestPestThreshold;
var maxOutputStim%;
var paftn:=0;
var rNum%:=2;
var numZero%, numFifty%, numSeventy%, numOneHundred%;
'var RMSin[3];
'var TrialrmsMzIn;
var avgVA;
var DigiStimTime;
var WhichOne%,FirstcVA%,SecondcVA%, ThirdcVA%,ArmPost%,ReflexInt%,ISInum%;
var ForceFeedbackLevel;
var FxIn,FyIn,FzIn,avgFxIn,avgFyIn,avgFzIn,MxIn,MyIn,MzIn,avgMxIn,avgMzIn,avgMyIn;
var waitforTMS%;
var whichcVAtest%[1];
var Forty$:="Forty";
var Seventy$:="Seventy";
var Onehundred$:="Onehundred";
var actualTriggerTime;
var stopIfMTRepeats%:=1;
var lastTMSFireTime;
var nextTMSFireTime:=1.0;
var bestPestLowBound%:=20;
var bestPestHighBound%:=80;
var bestPestStartTime := .03;
var bestPestEndTime := .1;
var bestPestSpread%:=7;
var interStimulusIntervalMin:=4;
var interStimulusIntervalMax:=5;
var interStimulusInterval:=3.5;
var jitter := 1;
var startUp%:=1;
var LocationData%;
'var ;

' basically lets us fire at a different intensity during the session
const  maxEpochs% := 1000;
var stimulusIntensities%[maxEpochs%];
var numEpochs% := 0;

' TMS control options
const TMSMAGSTIM200% := 0;
const TMSMAGSTIMOLD% := 1;
var   TMSwhichMagstim% := TMSMAGSTIM200%;
const TMSMAGSTIM200SPORT% := 3;    ' Check Device Manager under the hardware tab of My Computer to find out
                        ' which COM port is being used.  If it is connected to the main COM port
                        ' of the computer, then it will be COM 1.


const ForcePlate%[6]:={3,4,5,6,7,8}; 'Make channel specifier array for forces/moments from force plate
const TrigEventChan% := 6; ' Channel set for monitoring trigger events
var mWavePPArr[25];
var PPdiff[50];
var Protocol$:= "";'"pVARecProtocol";
var LastPulseTime:=0;
var FxLVL,FyLVL,FzLVL,MzLVL,EMGlvl;
var UpperFxLimit,LowerFxLimit,UpperFyLimit,LowerFyLimit,UpperFzLimit,LowerFzLimit,UpperMzLimit,LowerMzLimit,UpperEMGLimit,LowerEMGLimit;
var ForceMomentIn[6000][6];
var ForceMomentOut[6][6000];
var delta[6]:={.023, .023, .0093, 45, 45, 15};
var roll,pitch,yaw;
var smoothedMVCout[5500];
var smoothedMVCin[5500][6];
var AvgBicep[5500];'[1];
var BicepRMS[5500];
var TrialMVCin[3][6];
var TrialMVCout[3][1];
var TrialBicepMVC[3][1];
var MVCout;
var MVCin[6];
var avgMVCout;
var avgBicepMVC:=204.53;
var avgMVCin[6];
const FxChan%:= 3; 'Fx channel set
const FyChan%:= 4; 'Fy channel set
const FzChan%:= 5; 'Fz channel set
const MzChan%:= 10; 'Mz channel set
var dx, dy, dz, rotx, roty, rotz;

var t$:="t";
var cVAtestZeroComplete%:=0;
var cVAtestFiftyComplete%:=0;
var cVAtestSeventyComplete%:=0;
var cVAtestOnehundredComplete%:=0;
var cVAtestAllComplete%:=0;
var RestingTwitchTime;
var WaitTime;
var PercentMVC$;

if (TMSOpenConnection%(TMSMAGSTIM200SPORT%) < 0) then
  printlog("Error opening connection to Magstim\n");
  Halt;
endif;
'var mWavePPArr
var mWaveTriggers%[50];
'OOOOOOOOOOOOOOOOOO'
INITIALIZESubjectData();
proc INITIALIZESubjectData()
subjectID$ := Input$("Enter subject ID", "");
FilePathSet("", 0);
SampleAutoFile(1);
end;
'OOOOOOOOOOOOOOOOOO'

'Channel recording definitions
'SampleComment$(0,"");  'Set Sample Bar comment
'SampleComment$(-1,"pVA");  'Set Sample Bar label
'SampleWaveform(1, 0,1000); ' chan, port, ideal rate
'SampleCalibrate(1,"mV",0.001, 0); 'scale and offset
'SampleTitle$(1,"BicepEMG");
'SampleWaveform(2, 1,1000); ' chan, port, ideal rate
'SampleCalibrate(2,"mV",0.001, 0); 'scale and offset
'SampleTitle$(2,"tricepEM");
'SampleComment$(2,"");
'SampleWaveform(3, 10,1000); ' chan, port, ideal rate
'SampleTitle$(3,"Fx");
'SampleComment$(3,"");
'SampleWaveform(4, 11,1000); ' chan, port, ideal rate
'SampleTitle$(4,"Fy");
'SampleComment$(4,"");
'SampleWaveform(5, 12,1000); ' chan, port, ideal rate
'SampleTitle$(5,"Fz");
'SampleComment$(5,"");
'SampleWaveform(6, 13,1000); ' chan, port, ideal rate
'SampleTitle$(6,"Mx");
'SampleComment$(6,"");
'SampleEvent(7, 1,1, 50); 'Event+
'SampleTitle$(7,"TMS_trig");
'SampleComment$(7,"");
'SampleWaveform(8, 14,1000); ' chan, port, ideal rate
'SampleTitle$(8,"My");
'SampleComment$(8,"");
'SampleWaveform(9, 15,1000); ' chan, port, ideal rate
'SampleTitle$(9,"Mz");
'SampleComment$(9,"");
'SampleEvent(17, 0,1, 50); 'Event+
'SampleTitle$(17,"dtmr_tri");
'SampleComment$(17,"");
'SampleTitle$(31,"Keyboard");
'SampleOptimise(1,1,0,2,50);  'Set optimise mode (do this last)
'SampleMode(1); 'Continuous sampling
'----------------------------------------------------------------------------------------------------------------------'
'-------------------------------------Function for dealing with wait periods-------------------------------------------'
'----------------------------------------------------------------------------------------------------------------------'
func Waiting%();
var ret%:=1;
if Seconds() > WaitTime then 'exits when WaitTime reached
	ret%:= 0;'             'Idk if I actually need the return, it was used for closing the message box for NewsFlash
endif;
return ret%;
end;
'----------------------------------------------------------------------------------------------------------------------'
'----------------------------------------------------------------------------------------------------------------------'
'----------------------------------------------------------------------------------------------------------------------'
'------------------------------------------Allow for NewsFlash Message Boxes-------------------------------------------'
'----------------------------------------------------------------------------------------------------------------------'
'----------------------------------------------------------------------------------------------------------------------'
'  Arguments:
'  msg$                                            ' a string containing the message to display.
'  Tshow                                           ' the delay before the message box closes automatically in seconds (minimum 1.5).
'  x,y                                             ' the coordinates of the message box on the screen.
                                                            '(If x and y are set to 0, the message box will appear in mid-screen)
'  beep%                                            ' If set to 1 then the computer plays a short 'beep' when the message first appears.

var tflash;                                         ' global variable required by NewsFlash() and NFIdle%();
  proc NewsFlash(msg$,Tshow,x,y,beep%);           	' floating message box at coordinates with optional audible alert
  	var dummy;
  		if Tshow < 1.5 then
			Tshow:=1.5; 																	'set minimum display time
			endif;
  	tflash:=Tshow;                                	'tflash is a global variable
  		if beep% then
    		Sound("S*",1);                              'beep
  		endif;
  	Seconds(0);                                     'reset the clock
  DlgCreate("Info:",x,y);
  DlgLabel(1,msg$);
  DlgAllow(1023,NFIdle%);                         'Idle routine does the timing
  DlgButton(0,"");                                'hide cancel button
  DlgShow(dummy);
  return;
  end;

  func NFidle%();'Newsflash idle routine
  var ret%:=1;
  if Seconds() > tflash then' times up
    ret%:= 0;'             so close message box
  endif;
  return ret%;
  end;

'----------------------------------------------------------------------------------------------------------------------'
'----------------------------------------------------------------------------------------------------------------------'
'----------------------------------------------------------------------------------------------------------------------'
'----------------------------------------Set up the all the toolbars/buttons-------------------------------------------'
'----------------------------------------------------------------------------------------------------------------------'
'----------------------------------------------------------------------------------------------------------------------'

const allow%:=1023;
var MwaveButtonDisable%:=0;                ' Hold the value of the M-wave toobar buttons which are disabled
var toolText$;                      ' Holds the text string to appear in the toolbar

MwaveToolbar();
Halt;
'----------------------------------------------------------------------------------------------------------------------
' Set up the M-wave toolbar's buttons
'----------------------------------------------------------------------------------------------------------------------
proc MwaveToolbarButtons()            ' Buttons for M-wave Toolbar
ToolbarClear();
ToolbarSet(0,"",Idle%);                  'Call Idle%() whenever there is free time
ToolbarSet(1,"Quit", Back%);
ToolbarSet(6,"Record M-wave", RecMwave%);
ToolbarSet(3,"Reset M-max", ResetMwave%);
ToolbarSet(5,"Halt Record", HaltRec%);
ToolbarSet(2,"Go to pVA", pVAtoolbar%);
toolText$:="M-wave Protocol";          ' Sets the text to appear on the left in the toolbar
ToolbarText(toolText$);                         ' Puts the toolText into the toolbar (in case we are returning to this toolbar)

if MwaveButtonDisable% = 6 then         ' When recording, all buttons except "Halt Record" should be disabled
  ToolbarEnable(6, 0);                ' disables Record button
  ToolbarEnable(3, 0);                          ' disables Reset button
  ToolbarEnable(2, 0);                          ' disables pVA button
  ToolbarEnable(5, 1);              ' and enables Halt button
endif;
if MwaveButtonDisable% = 3 then         ' If M-max has been reset, then enable M-max calculation and record
  ToolbarEnable(3, 0);              ' disables Reset button
  ToolbarEnable(6, 1);                          ' enables Record button
endif;
if MwaveButtonDisable% = 5 then         ' When finished recording allow calculation of M-max
  ToolbarEnable(6, 0);                ' disables Record button
  ToolbarEnable(3, 1);                          ' enables Reset button
  ToolbarEnable(2, 0);                          ' disables pVA button
  ToolbarEnable(5, 0);              ' and disables Halt button
endif;
if MwaveButtonDisable% = 0 then         ' Default setting on startup
  ToolbarEnable(6, 1);                ' Record button enabled
  ToolbarEnable(3, 0);                          ' Reset button disabled
  ToolbarEnable(5, 0);              ' Halt button disabled
  ToolbarEnable(2, 1);                          ' and pVA button disabled           CURRENTLY ENABLED!!!!
endif;
end

'----------------------------------------------------------------------------------------------------------------------'
'----------------------------------------------------------------------------------------------------------------------'
'----------------------------------------------------------------------------------------------------------------------'
'------------------------------------------The M-wave Toolbar Functions------------------------------------------------'
'----------------------------------------------------------------------------------------------------------------------'
'----------------------------------------------------------------------------------------------------------------------'

proc MwaveToolbar()
MwaveToolbarButtons();                ' Set up main toolbar buttons
var Protocol%:=MwaveProtocol%;                  ' Set "Protocol" Variable to Mwave
var MwaveButtonDisable%:= 0;                    '
Toolbar(toolText$, allow%);                ' Displays and waits at toolbar
end;
'----------------------------------------------------------------------------------------------------------------------
' Record M-wave
'----------------------------------------------------------------------------------------------------------------------
'var MwaveThreshdata%:=-1;                           ' Handle of new data file (Spike2 sets it to 0)
var sTime;                                      ' The last time we looked at the idle routine
var pLev;                                       ' Previous horizontal cursor position
var fullMax,fullMin;                            ' Full input range of channel based on scale and offset
var chan% := 1;
func RecMwave%()                ' Begin Recording M-wave

View(LogHandle());            'Make log view the current view
EditSelectAll();            'Select all text in log view
EditClear();              'Delete it
Window(0,80,100,100);          'Display it at the bottom of the screen
WindowVisible(1);            'Make it visbible

if (MwaveThreshdata%>0) then                      ' If there is already a data view open...
  View(MwaveThreshdata%);                       ' ...close it
  FileClose(0, -1);                             ' No point setting data% to 0...
endif;

MwaveThreshdata%:=FileNew(0,0);                 ' Open a new data file for sampling
if MwaveThreshdata%<0 then
    SampleStop();
  FileClose(-1,-1);
  MwaveThreshdata%:=FileNew(0,0);
    if MwaveThreshdata%<0 then
        Message("Unable to open new data file");Halt;
    endif;
endif;
View(MwaveThreshdata%).XRange(-1);
View(MwaveThreshdata%).WindowVisible(1);
View(MwaveThreshdata%).DrawMode(-1,3);              'Set event draw mode to lines (3 for waveform)
View(MwaveThreshdata%).Window(0,0,60,100);            'Make data window right half of screen
cScale := ChanScale(curChan%);
cOffset := ChanOffset(curChan%);
'View(MwaveThreshdata%).FiltCalc(3, BinSize(1), highPassFilter[]); 'set the filter
'View(MwaveThreshdata%).ChanProcessAdd(1, 1, 0.01); 'Channel, 1=Smooth, Time constant (s)
'View(MwaveThreshdata%).ChanProcessAdd(1, 9, 0.01); 'Channel, 9=Median filter, Time constant (s)
ChanHide(31);
ViewTrigger(TrigEventChan%, .1, .9, 1,1);

resultViewH%:=SetResult(5000, BinSize(1), -.1, "Filtered EMG", "s", ChanUnits$(1), "Time", "EMG-apb");
View(resultViewH%).DrawMode(1, 3);
View(resultViewH%).YRange(1, -0.250, 0.250);
View(resultViewH%).WindowVisible(1);
View(resultViewH%).CursorNew(XToBin(0));
View(resultViewH%).Window(0,0,60,80); 'Make EMG results graph window sit between log view and sampling data
Colour(12,6);
'M-wave Peak-to-Peak Bar Graph
View(MwaveThreshdata%); ' View sampling data
MwaveBarGraph%:=SetResult(3,1,0,"M-wave Level","");
View(MwaveBarGraph%).XRange(0,3);
View(MwaveBarGraph%).YRange(1,((0 * cScale)+ cOffset),(14*cScale)+cOffset);      'Set Y range to match source waveform channel
View(MwaveBarGraph%).Window(60,0,100,100); 'Make bar graph window right portion of screen
FrontView(MwaveBarGraph%);
Colour(12,6);
FrontView(LogHandle());              'Bring the Log view to the front
FrontView(MwaveBarGraph%);                  'Bring the bar graph results view to the front
FrontView(MwaveThreshdata%);          'Bring the data view to the front
FrontView(resultViewH%);                    'Bring the filtered data view to the front
'OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO'
'OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO'
'OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO'

sTime := 0;                                     ' set start of anaylsis time
' here are all the variables we need to re-initialize every time we start a new recording
'currentTrigTime:=-1;
'updateNecessary%:=0;
stimcount% := 0;
'TMSlastCommandTime := -1;
'lastStimOutput% := -1;
SampleStart();                                  ' Start sampling
ToolbarEnable(2, 0);                ' disables pVA button
ToolbarEnable(3, 0);                            ' disables Reset button
ToolbarEnable(6, 0);                            ' disables Record button
ToolbarEnable(5, 1);              ' and enables Halt button
MwaveButtonDisable%:=6;              ' Set the global varible to keep track of it all
return 1;                    ' and stay in current toolbar
end;


func Idle%()'The Idle routine is called when PC has time
var eTime;
var newestEvent;
FrontView(MwaveThreshData%);
'View(MwaveThreshData%); This gives an error... probably should just delete it, don't think it actually adds any usefulness
'----------------------------------------------------------------------------------------------------------------------------------------------------'
'----------------------------------------------------------------M-wave Idle Functions------------------------------------------'
'----------------------------------------------------------------------------------------------------------'
    if (MwaveThreshdata%>=0) then
        var curTime;
        curTime := View(MwaveThreshdata%).Maxtime();

  if (updateNecessary% and (View(MwaveThreshdata%).Maxtime()-currentTrigTime >= .9)) then
    printlog("Updating view\n");
    updateData();
    DoMwaveAnalyze%();
    'View(resultViewH%).YRange(1, View(resultViewH%).YLow(1), View(resultViewH%).YHigh(1)); 'scaling of results view based on current sampled data
''''''''''''''''''''''''''''
        View(resultViewH%).Draw(); ''''WHY NOT MOVE THIS LINE TO updateData FUNC?????''''
''''''''''''''''''''''''''''
        updateNecessary%:=0;
    'else
        'yield(0.001); 'ensure it waits until 1 sec has passed since trigger
  endif;
    newestEvent := View(MwaveThreshdata%).NextTime(TrigEventChan%, currentTrigTime+.1);
        'printlog("%f\n", newestEvent);

  if (newestEvent > currentTrigTime) then
    printlog("newer event found\n");
      printlog("Updating event\n");
      stimcount%+=1;
        currentTrigTime := newestEvent;
        printlog("%f\n",currentTrigTime);
        updateNecessary%:=1;
        'yield(0.001);
    endif;
endif;
'----------------------------------------------------------------------------------------------------------------------------------------------------'
'----------------------------------------------------------------pVA Idle Functions------------------------------------------'
'----------------------------------------------------------------------------------------------------------'
if ((Protocol$ = "pVA_Thresh_Protocol")) then
    FrontView(pVAThreshdata%);
    'if(View(pVAThreshdata%).Maxtime() - .2 >= curTime) then
    'if(View(pVAThreshdata%).Maxtime() - FeedbackTime >= 0) then
  curTime := View(pVAThreshdata%).Maxtime();
  if curTime > lTime then
    ForceFeedbackLevel:= View(pVAThreshdata%).ChanValue(BicepEMGchan%,MaxTime()-BinSize(1)); 'do I want it as current value?
    'ForceFeedbackLevel:=view(pVAThreshdata%).ChanMeasure(BicepEMGchan%,11,curTime-.5,curTime); 'or as RMS amp over the last 200ms
    ArrConst(View(ForceFeedbackBarGraph%).[:1],ForceFeedbackLevel);
    DrawAll();
    lTime:=curTime;
  endif;
  return 1;
endif;
if ((Protocol$ = "REC_pVA")) then
    FrontView(pVAdata%);
    if(View(pVAdata%).Maxtime() - LastPulseTime >= 5) then
        curTime := View(pVAdata%).Maxtime();
        'ForceFeedbackLevel:= ChanValue(FxChan%,MaxTime()-BinSize(1));
        ForceFeedbackLevel:=view(pVAdata%).ChanMeasure(BicepEMGchan%,11,curTime-.5,curTime); 'or as RMS amp over the last 200ms
        ArrConst(View(ForceFeedbackBarGraph%).[:1],ForceFeedbackLevel);
        DrawAll();
'-------------------------------------------------------
' Monitor Force levels and do Feedback display colouring
'-------------------------------------------------------
        'FxLVL:=ChanMeasure(FxChan%,2,curTime-.2,curTime);'find the mean of Fx over the last 200ms
        'FyLVL:=ChanMeasure(FyChan%,2,curTime-.2,curTime);'find the mean of Fy over the last 200ms
        'FzLVL:=ChanMeasure(FzChan%,2,curTime-.2,curTime);'find the mean of Fz over the last 200ms
        'MzLVL:=ChanMeasure(MzChan%,11,curTime-.5,curTime);'find the RMS amplitude of Mz over the last 500ms
        EMGlvl:=view(pVAdata%).ChanMeasure(BicepEMGchan%,11,curTime-.5,curTime);
        docase

        case EMGlvl < LowerEMGLimit then
            view(ForceFeedbackBarGraph%).ChanColourSet(1, 1, 1, 0, 0); 'Set feedback graph to red if below lower limit and...
            view(ForceFeedbackBarGraph%).ChanColourSet(1, 2, 1, 0, 0);
            'Sound("S!",1+8192);                                        '... play asynchronous sound (DOESNT WORK?)
        case EMGlvl > UpperEMGLimit then
            view(ForceFeedbackBarGraph%).ChanColourSet(1, 1, 1, 0, 0); 'Set feedback graph to red if above upper limit and...
            view(ForceFeedbackBarGraph%).ChanColourSet(1, 2, 1, 0, 0);
        else
            view(ForceFeedbackBarGraph%).ChanColourSet(1, 1, 0, 1, 0); 'Set feedback graph to green if between limits
            view(ForceFeedbackBarGraph%).ChanColourSet(1, 2, 0, 1, 0);
        endcase;
'-------------------------------------------------------
' Trigger Digitimer if forces are in desired range
'-------------------------------------------------------
        if  (EMGlvl < UpperEMGLimit and EMGlvl > LowerEMGLimit) then
            yield(0);
            counter%+=1;
            if counter% = 10 then
                'and  FyLVL <= UpperFyLimit and FyLVL >= LowerFyLimit
                'and  FzLVL <= UpperFzLimit and FzLVL >= LowerFzLimit) then  'If force is in target range then....
                SampleKey(t$);                                              'Send pulse to digitimer
                LastPulseTime:=View(pVAdata%).Maxtime();                    'Reset when the last pulse was sent
                'getTwitch%:=1;                                               'Get twitch data
                getTwitchAmp();
            endif;
        else
            counter%:=0;
        endif;
        'if(curTime - LastPulseTime = 30) then
        '    SampleKey(t$);                                              'Trigger digitimer for resting twitch
        '    RestingTwitchTime:=View(pVAdata%).Maxtime();
        '    getRestingTwitch%:=1;                                        'Get resting state twitch data
        '    getTwitchAmp();
        'endif;
        'if(curTime - RestingTwitchTime = 60) then
        '
        'endif;
    endif;
endif;
'----------------------------------------------------------------------------------------------------------------------------------------------------'
'----------------------------------------------------------------cVA Idle Functions------------------------------------------'
'----------------------------------------------------------------------------------------------------------'
FrontView(cVAdata%);
if (cVAdata%>=0) then
    if ((Protocol$ = "cVA")) then
        if (View(cVAdata%).Maxtime() - TMSlastCommandTime > 0.5) then
      TMSSetRemoteControl%(TMSMAGSTIM200SPORT%);
    endif;
    'FrontView(cVAdata%);
       if(View(cVAdata%).Maxtime() - LastStimTime >= 5) then
        curTime := view(cVAdata%).Maxtime();
        ForceFeedbackLevel:=view(cVAdata%).ChanMeasure(BicepEMGchan%,11,curTime-.5,curTime); 'or as RMS amp over the last 200ms
        ArrConst(View(ForceFeedbackBarGraph%).[:1],ForceFeedbackLevel);
        DrawAll();
    'if((curTime - LastStimTime) > 5) then


'-------------------------------------------------------
' Monitor Force levels and do Feedback display colouring
'-------------------------------------------------------
        EMGlvl:=view(cVAdata%).ChanMeasure(BicepEMGchan%,11,curTime-.5,curTime);

        docase
        case ForceFeedbackLevel < LowerEMGLimit then
            view(ForceFeedbackBarGraph%).ChanColourSet(1, 1, 1, 0, 0); 'Set feedback graph to red if below lower limit and...
            view(ForceFeedbackBarGraph%).ChanColourSet(1, 2, 1, 0, 0);
            'Sound("S!",1+8192);                                        '... play asynchronous sound (DOESNT WORK?)
        case ForceFeedbackLevel > UpperEMGLimit then
            view(ForceFeedbackBarGraph%).ChanColourSet(1, 1, 1, 0, 0); 'Set feedback graph to red if above upper limit and...
            view(ForceFeedbackBarGraph%).ChanColourSet(1, 2, 1, 0, 0);
        else
            view(ForceFeedbackBarGraph%).ChanColourSet(1, 1, 0, 1, 0); 'Set feedback graph to green if between limits
            view(ForceFeedbackBarGraph%).ChanColourSet(1, 2, 0, 1, 0);
        endcase;
'-------------------------------------------------------
' Trigger Magstim if forces are in desired range
'-------------------------------------------------------
            if  (ForceFeedbackLevel <= UpperEMGLimit and ForceFeedbackLevel >= LowerEMGLimit) then  'If force is in target range then....
                yield(0);
                counter%+=1;
                if counter% >= 10 then
                  docase
                    case cVAprotocol$ = "Arm Posture" then
                      'TMSSetRemoteControl%(1);
                      'armTMS%();
                      TMSTriggerTMS%(1);                                      'Send pulse to magstim
                      LastStimTime:=view(cVAdata%).MaxTime();
                      Marking%();                                             'Create marker with percent MVC
                      SampleKey(s$);
                      getMEP%();
                    case cVAprotocol$ = "Paired Pulse" then
                      TMSTriggerTMS%(1);                                      'Send pulse to magstim
                      LastStimTime:=view(cVAdata%).MaxTime();
                      Marking%();                                             'Create marker with percent MVC
                      SampleKey(s$);
                      getMEP%();
                    case PCSprotocol$ = "40ms Cutaneous Reflex" then
                      DigiStimTime:=view(cVAdata%).MaxTime();
                      SampleKey(t$);                                          'Send pulse to digitimer then magstim 40ms later
                      'if curTime > DigiStimTime + .035 then
                          TMSTriggerTMS%(1);
                          actualTriggerTime:=view(cVAdata%).MaxTime();
                          Marking%();                                         'Create marker with percent MVC
                          SampleKey(s$);
                          getMEP%();
                      'endif;
                    case PCSprotocol$ = "70ms Cutaneous Reflex" then
                      'armTMS%();
                      DigiStimTime:=view(cVAdata%).MaxTime();
                      SampleKey(t$);                                          'Send pulse to digitimer then magstim 40ms later
                      'if curTime > DigiStimTime + .065 then
                      '        TMSTriggerTMS%(1);
                      '        SampleKey(s$);
                      '        getMEP%();
                      'endif;                                    'Send pulse to digitimer then magstim 70ms later
                    case PCSprotocol$ = "100ms Cutaneous Reflex" then
                      'armTMS%();
                      DigiStimTime:=view(cVAdata%).MaxTime();
                      'SampleKey(t$);                                          'Send pulse to digitimer then magstim 40ms later
                      'if curTime > DigiStimTime + .095 then
                          TMSTriggerTMS%(1);
                          Marking%();
                          SampleKey(s$);
                          SampleKey(t$);
                              getMEP%();
                      'endif;                                 'Send pulse to digitimer then magstim 100ms later
                  endcase;
                LastStimTime:=View(cVAdata%).Maxtime();                     'Reset when the last pulse was sent
                endif
                else
                counter%:=0;
                'endif;
            endif;
    endif;
    endif;
    if waitforTMS% = 25 then
       Finish%()
    endif;
endif;
'----------------------------------------------------------------------------------------------------------------------------------------------------'
'----------------------------------------------------------------rMT Idle Functions------------------------------------------'
'----------------------------------------------------------------------------------------------------------'
if ((Protocol$ = "rMT")) then
  if (LocationData%>=0) then
    curTime := View(LocationData%).Maxtime();
    if (updateNecessary% and (View(LocationData%).Maxtime()-currentTrigTime >= .9)) then
      printlog("Updating view\n");
      updateLocation();
      DoMTAnalyze%();
      View(resultViewH%).Draw();
      updateNecessary%:=0;
    endif;
    newestEvent := View(LocationData%).NextTime(7, currentTrigTime+.1);
    if (newestEvent > currentTrigTime) then
      currentTrigTime := newestEvent;
      updateNecessary%:=1;
    endif;
  endif;
endif;
'------------------------------------------'
if ((Protocol$ = "rMT")) then
if (data%>=0) then
  curTime := View(data%).Maxtime();

  if (updateNecessary% and (View(data%).Maxtime()-currentTrigTime >= .9)) then
    printlog("Updating view\n");
    updateData();
    DoAnalyze%();
    View(resultViewH%).YRange(1, View(resultViewH%).YLow(1), View(resultViewH%).YHigh(1));
    View(resultViewH%).Draw();
    updateNecessary%:=0;
  endif;

  newestEvent := View(data%).NextTime(2, currentTrigTime+.1);
  if (newestEvent > currentTrigTime) then
    printlog("newer event found\n");
      printlog("Updating event\n");
      numStim%+=1;
      currentTrigTime := newestEvent;
      updateNecessary%:=1;
    endif;
        endif;
    endif;
return 1;'Stay in toolbar
end;

proc updateData()
    View(MwaveThreshdata%).ChanData(1, View(resultViewH%,1).[], currentTrigTime-.1, currentTrigTime+.9);
end;
func MwavePeakToPeak(startTime, endTime)
  var minVal, maxVal, i%;
    View(resultViewH%).Minmax(1, XToBin(startTime), XToBin(endTime), minVal, maxVal);
    printlog("current peak to peak:", maxVal - minVal);
    mWavePPArr[stimcount%]:= maxVal - minVal;
    if(stimcount% > 2) then
    ArrConst(View(MwaveBarGraph%).[:3],mWavePPArr[stimcount%-3:stimcount%]);                      'Set bar graph to new peak to peak value
    DrawAll();  'update result views
    endif
  return maxVal - minVal;
end;
func DoMwaveAnalyze%();
'if Protocol%(MwaveProtocol%) then
    var curPeakToPeak;
    view(resultViewH%); 'make sure we are looking at the results view, otherwise we get peak-to-peak of the same sampled data every time
    'yield(1); 'shouldn't need this because it is built into idle func
    curPeakToPeak:=MwavePeakToPeak(.03,.3);
if (stimcount% > 1) then
    PPdiff[stimcount%-2]:= curPeakToPeak - prevPeakToPeak;
    AnalyzeMwave(curPeakToPeak);
    return 0;
endif
'if Protocol%(pVAProtocol%) then
'
'endif

end
proc AnalyzeMwave(curPeakToPeak)
    var MwaveMax, MwaveStimMax, avgPPdiff;
    var MwaveStimIntensity;
    var fName$,ret%;
    if (stimcount% > 2) then
        avgPPdiff:= (PPdiff[stimcount%-2] + PPdiff[stimcount%-1] + PPdiff[stimcount%])/3;
        if (avgPPdiff > 0.01) then
          Newsflash("Increase Stimulus Intensity by 10mA",5,0,05,1);
          prevPeakToPeak:=curPeakToPeak;
        ' go back to idle or whatever to continue recording/triggering
        else 'plateau has been reached and we calculate and save final information
          SampleStop();                                   ' Stop sampling
          Newsflash("M-Max Stimulus Intensity Found",10.0,0,05,1);
          var i%, PPvals%;
          fName$ := View(MwaveThreshData%).FileName$(3);
          PPvals% := FileNew(1);
          for i%:= 0 to len(mWavePPArr[])-1 do;
              View(PPvals%).print("%g",mWavePPArr[i%]);
          next;
          if (PPvals% >= 0) then
            ret% := View(PPvals%).FileSaveAs(print$("%s%s", fName$, "_mWave_PeaktoPeaks.txt"), 1, 0, "Save analysis as...");
          if (ret% < 0) then
            View(PPvals%);
            FileClose(0, -1);
          else
            View(PPvals%);
              FileClose();
          endif;

        endif;
        View(MwaveThreshdata%).FileSaveAs(print$("%s%s", fName$, "_mMax"), -1);
    endif;
endif;
end;
'----------------------------------------------------------------------------------------------------------------------
' Reset M-max
'----------------------------------------------------------------------------------------------------------------------
func ResetMwave%()
    var i%;
    for i%:= 0 to len(mWavePPArr[]) - 1 do;
    mWavePPArr[i%]:=0;
    next;
    for i%:= 0 to len(PPdiff[]) - 1 do;
    PPdiff[i%]:=0;
    next;
    'MwaveMax:=0;
    stimcount%:=0;
    prevPeakToPeak:=0;
    curPeakToPeak:=0;
ToolbarEnable(3, 0);              ' disables button 3
ToolbarEnable(6, 1);                            ' enables button 6
ToolbarEnable(4, 1);              ' enables button 4
MwaveButtonDisable%:=3;              ' sets the global varible to track button disables
return 1;                    ' and stay in current toolbar
end;
'----------------------------------------------------------------------------------------------------------------------
' Halt M-wave recording
'----------------------------------------------------------------------------------------------------------------------
func HaltRec%()


'if (MwaveThreshdata%>0) and                     ' if no data in file, stop will close it
'    (ViewKind(MwaveThreshdata%) <> 0) then MwaveThreshdata% := 0
'    else View(MwaveThreshdata%).FileSaveAs("", -1);
'  View(MwaveThreshdata%);
'  FileClose(0,-1);
'    MwaveThreshdata%:= -1;
'endif;
  'ToolbarEnable(2, 1);                ' disables button 2
  'ToolbarEnable(3, 1);                          ' enables button 3
  'ToolbarEnable(4, 1);                          ' disables button 4
  'ToolbarEnable(6, 1);                          ' disables button 6
  'ToolbarEnable(5, 1);              ' and disables button 5
'MwaveButtonDisable%:=5;              ' sets the global varible to track button disables
'fileMwave% += 1;
'SampleAutoName$(Print$("%s_Mwave", subjectID$));
return 1;                    ' and stay in current toolbar
end;
'----------------------------------------------------------------------------------------------------------------------
' Move to pVA toolbar
'----------------------------------------------------------------------------------------------------------------------
func pVAtoolbar%()                ' Do the pVA toolbar
pVAtoolbarButtons();              ' Set up pVA toolbar buttons
var pVAButtonDisable%:= 0;                      ' Default toolbar button status
Toolbar(toolText$, allow%);            ' Displays and waits at toolbar
MwaveToolbarButtons();              ' When we leave, set up buttons for main toolbar again
return 1;                    ' Stay in main toolbar
end;
proc pVAToolbarButtons()            ' Buttons for pVA Toolbar
ToolbarClear();
ToolbarSet(0,"",Idle%);                  ' Call Idle%() whenever there is free time
ToolbarSet(1,"Quit", Back%);
ToolbarSet(4,"Record pVA", RECpVA%);
ToolbarSet(5,"Find MVC", pVAthresh%);
ToolbarSet(3,"Halt Rec/Set", HaltRec%);
ToolbarSet(2,"Go to cVA", cVAtoolbar%);
toolText$:="pVA Protocol";              ' Sets the text to appear on the left in the toolbar
ToolbarText(toolText$);                         ' Puts the toolText into the toolbar (in case we are returning to this toolbar)

if pVAButtonDisable% = 5 then         ' When setting VA threshold, all buttons except "Halt Rec/Set" should be disabled
  ToolbarEnable(4, 0);                ' disables Record button
  ToolbarEnable(5, 0);                          ' disables Set Thresh button
  ToolbarEnable(2, 0);                          ' disables cVA button
  ToolbarEnable(3, 1);              ' and enables Halt button
endif;
if pVAButtonDisable% = 4 then         ' When recording pVA threshold, all buttons except "Halt Rec/Set" should be disabled
  ToolbarEnable(4, 0);                ' disables Record button
  ToolbarEnable(5, 0);                          ' disables Set Thresh button
  ToolbarEnable(2, 0);                          ' disables cVA button
  ToolbarEnable(3, 1);              ' and enables Halt button
endif;
if pVAButtonDisable% = 3 then         ' When finished recording allow cVA button
  ToolbarEnable(4, 0);                ' disables Record button
  ToolbarEnable(3, 0);                          ' disables Halt button
  ToolbarEnable(2, 1);                          ' enables pVA button
  ToolbarEnable(5, 0);              ' and disables Set Thresh button
endif;
if pVAButtonDisable% = 0 then         ' Default setting on startup
  ToolbarEnable(4, 1);                ' Record button enabled
  ToolbarEnable(5, 1);                          ' Set Thresh button enabled
  ToolbarEnable(3, 0);              ' Halt button disabled
  ToolbarEnable(2, 1);                          ' cVA button disabled
  ToolbarEnable(1, 1);                          ' and quit button enabled
endif;
end
'----------------------------------------------------------------------------------------------------------------------
' Move to cVA toolbar
'----------------------------------------------------------------------------------------------------------------------
func cVAtoolbar%()                ' Do the cVA toolbar
cVAtoolbarButtons();              ' Set up cVA toolbar buttons
'var cVAButtonDisable%:= 0;                      ' Default toolbar button status
Toolbar(toolText$, allow%);            ' Displays and waits at toolbar
pVAToolbarButtons();              ' When we leave, set up buttons for pVA toolbar again
return 1;                    ' Stay in cVA toolbar
end;
proc cVAToolbarButtons()            ' Buttons for cVA Toolbar
ToolbarClear();
ToolbarSet(0,"",Idle%);                  ' Call Idle%() whenever there is free time
ToolbarSet(8,"Set Parameters", SetParameters%);
ToolbarSet(7,"Find MT location", LocateMT%);
ToolbarSet(6,"Find rMT", GetrMT%);
ToolbarSet(5,"Arm Posture", ArmPostureToolbar%);
ToolbarSet(4,"Paired Pulse", PairedPulseToolbar%);
ToolbarSet(3,"Cutaneous Stim", pcsToolbar%);
ToolbarSet(2,"Halt Rec/Set", HaltRec%);
ToolbarSet(1,"Quit", Back%);
toolText$:="Cortical VA Protocols";        ' Sets the text to appear on the left in the toolbar
ToolbarText(toolText$);                         ' Puts the toolText into the toolbar (in case we are returning to this toolbar)
'
'
'if pVAButtonDisable% = 4 then             ' When finding rMT threshold, all buttons except "Halt Rec/Set" should be disabled
'  ToolbarEnable(4, 1);                ' disables rMT button
'  ToolbarEnable(3, 1);                          ' disables cVA button
'  ToolbarEnable(2, 1);              ' and enables Halt button
'endif;
'if pVAButtonDisable% = 3 then             ' When rMT is found allow cVA button
'  ToolbarEnable(4, 1);                ' enables Record button
'  ToolbarEnable(3, 1);                          ' disables Halt button
'  ToolbarEnable(5, 1);              ' and disables Set Thresh button
'endif;
'if pVAButtonDisable% = 0 then             ' Default setting on startup
'  ToolbarEnable(4, 1);                ' Record button enabled
'  ToolbarEnable(3, 1);                          ' Set Thresh button enabled
'  ToolbarEnable(2, 1);                          ' cVA button disabled
'  ToolbarEnable(1, 1);                          ' and quit button enabled
'endif;
end
'----------------------------------------------------------------------------------------------------------------------
' Move to cVA subprotocol toolbars
'----------------------------------------------------------------------------------------------------------------------
func ArmPostureToolbar%()            ' Do the cVA toolbar
ArmPostureToolbarButtons();              ' Set up cVA toolbar buttons                      ' Default toolbar button status
Toolbar(toolText$, allow%);            ' Displays and waits at toolbar
cVAToolbarButtons();              ' When we leave, set up buttons for cVA toolbar again
return 1;                    ' Stay in cVA toolbar
end;
proc ArmPostureToolbarButtons()            ' Buttons for cVA Toolbar
ToolbarClear();
ToolbarSet(0,"",Idle%);                  ' Call Idle%() whenever there is free time
ToolbarSet(6,"100%", cVAtestOnehundred%);
ToolbarSet(5,"75%", cVAtestSeventy%);
ToolbarSet(4,"50%", cVAtestFifty%);
ToolbarSet(3,"At Rest", cVAtestZero%);
ToolbarSet(2,"All", cVAtestAll%);
ToolbarSet(1,"Quit", Back%);
toolText$:="Arm Posture cVA Protocols";        ' Sets the text to appear on the left in the toolbar
ToolbarText(toolText$);                         ' Puts the toolText into the toolbar (in case we are returning to this toolbar)
end
func PairedPulseToolbar%()            ' Do the cVA toolbar
ArmPostureToolbarButtons();              ' Set up cVA toolbar buttons                      ' Default toolbar button status
Toolbar(toolText$, allow%);            ' Displays and waits at toolbar
cVAToolbarButtons();              ' When we leave, set up buttons for pVA toolbar again
return 1;                    ' Stay in cVA toolbar
end;
proc PairedPulseToolbarButtons()            ' Buttons for cVA Toolbar
ToolbarClear();
ToolbarSet(0,"",Idle%);                  ' Call Idle%() whenever there is free time
ToolbarSet(6,"100%", cVAtestOnehundred%);
ToolbarSet(5,"75%", cVAtestSeventy%);
ToolbarSet(4,"50%", cVAtestFifty%);
ToolbarSet(3,"At Rest", cVAtestZero%);
ToolbarSet(2,"All", cVAtestAll%);
ToolbarSet(1,"Quit", Back%);
toolText$:="Paired Pulse cVA Protocols";        ' Sets the text to appear on the left in the toolbar
ToolbarText(toolText$);                         ' Puts the toolText into the toolbar (in case we are returning to this toolbar)
end
func pcsToolbar%()            ' Do the cVA toolbar
pcsToolbarButtons();              ' Set up cVA toolbar buttons                      ' Default toolbar button status
Toolbar(toolText$, allow%);            ' Displays and waits at toolbar
cVAToolbarButtons();              ' When we leave, set up buttons for pVA toolbar again
return 1;                    ' Stay in cVA toolbar
end;
proc pcsToolbarButtons()            ' Buttons for cVA Toolbar
ToolbarClear();
ToolbarSet(0,"",Idle%);                  ' Call Idle%() whenever there is free time
ToolbarSet(6,"100%", cVAtestOnehundred%);
ToolbarSet(5,"75%", cVAtestSeventy%);
ToolbarSet(4,"50%", cVAtestFifty%);
ToolbarSet(3,"At Rest", cVAtestZero%);
ToolbarSet(2,"All", cVAtestAll%);
ToolbarSet(1,"Quit", Back%);
toolText$:="Cutaneous Stim cVA Protocols";        ' Sets the text to appear on the left in the toolbar
ToolbarText(toolText$);                         ' Puts the toolText into the toolbar (in case we are returning to this toolbar)
end
'----------------------------------------------------------------------------------------------------------------------'
'----------------------------------------------------------------------------------------------------------------------'
'----------------------------------------------------------------------------------------------------------------------'
'---------------------------------------------The pVA Toolbar Functions------------------------------------------------'
'----------------------------------------------------------------------------------------------------------------------'
'----------------------------------------------------------------------------------------------------------------------'
func pVAthresh%()
pVAButtonDisable%:=4;          ' sets the global varible to track button disables
pVAThreshdata%:=FileNew(0,0);                 ' Open a new data file for sampling
if pVAThreshdata%<0 then
    SampleStop();
  FileClose(-1,-1);
  pVAThreshdata%:=FileNew(0,0);
    if pVAThreshdata%<0 then
        Message("Unable to open new data file");Halt;
    endif;
endif;
View(pVAThreshdata%).XRange(-1);
View(pVAThreshdata%).WindowVisible(1);
View(pVAThreshdata%).DrawMode(-1,3);              'Set event draw mode to lines (3 for waveform)
View(pVAThreshdata%).Window(0,0,60,100);            'Make data window right half of screen
'View(pVAdata%).FiltCalc(3, BinSize(1), highPassFilter[]); 'set the filter
'View(pVAdata%).ChanProcessAdd(1, 1, 0.01); 'Channel, 1=Smooth, Time constant (s)
'View(pVAdata%).ChanProcessAdd(1, 9, 0.01); 'Channel, 9=Median filter, Time constant (s)
ChanHide(31);
ViewTrigger(TrigEventChan%, .1, .9, 1,1);
Protocol$:="pVA_Thresh_Protocol"; 'Set Protocol
resultViewH%:=SetResult(-1,6000, BinSize(1), -.1, "Force", "s", ChanUnits$(1), "Time", "Force"); 'I think we might just need the bar graph? but maybe not, because calcs are done from result views?
'View(resultViewH%).DrawMode(3, 3);
'View(resultViewH%).YRange(1, -.1, .1);
'View(resultViewH%).WindowVisible(0);
'View(resultViewH%).CursorNew(XToBin(0));
'View(resultViewH%).Window(0,0,60,50); 'Make results graph window sit between log view and sampling data
Colour(12,6);
'Force Feedback Bar Graph
FrontView(pVAThreshdata%);
ForceFeedbackBarGraph%:=SetResult(1,1,0,"MVC Level","");
FrontView(ForceFeedbackBarGraph%);
View(ForceFeedbackBarGraph%).XRange(0,1);
View(ForceFeedbackBarGraph%).YRange(1,0,1000);      'Set Y range to match source waveform channel
View(ForceFeedbackBarGraph%).Window(60,0,100,100); 'Make bar graph window right 40% of screen
FrontView(LogHandle());              'Bring the Log view to the front
FrontView(ForceFeedbackBarGraph%);          'Bring the bar graph results view to the front
FrontView(pVAThreshdata%);                  'Bring the data view to the front
'FrontView(resultViewH%);                    'Bring the filtered data view to the front

var ok%;', dx, dy, dz, rotx, roty, rotz;
var delta[6]; 'Cant use this because apparently Spike2 hates linear algebra
DlgCreate("Set Distance and Angles from Elbow Joint to Force Plate");  'dialog box for setting joint distance/angles
    DlgReal(1,"dx (cm)",-100,100,0,0,.1);
    DlgReal(2,"dy (cm)",-100,100,0,0,.1);
    DlgReal(3,"dz (cm)",-100,100,0,0,.1);
    DlgReal(4,"\u03b8 x (degrees)",-180,180,0,0,1);
    DlgReal(5,"\u03b8 y (degrees)",-180,180,0,0,1);
    DlgReal(6,"\u03b8 z (degrees)",-180,180,0,0,1);
    DlgButton(0,"Cancel");
    DlgButton(1,"OK");
    ok% := DlgShow(dx, dy, dz, rotx, roty, rotz);
    dx:= dx/100; dy:= dy/100; dz:= dz/100;
    rotx:= rotx; roty:= roty; rotz:= rotz;
    'dx:= DlgValue(1); dy:= DlgValue(2); dz:= DlgValue(3);
    'rotx:= DlgValue(4); roty:= DlgValue(5); rotz:= DlgValue(6);
'delta[]:={DlgValue(1)}
'ArrConst(delta[0], dx); ArrConst(delta[1], dy); ArrConst(delta[2], dz); 'initializing the vector for subsequent calculations
'ArrConst(delta[3], rotx); ArrConst(delta[4], roty); ArrConst(delta[5], rotz);
TrialCount%:=0; 'Set Trial number to zero before recording starts
var i%;
SampleStart(); 'begin sampling

for i%:=0 to 2 do
    FrontView(pVAThreshdata%);
    MVCstartTime[i%]:=View(pVAThreshdata%).Maxtime();                               'Track MVC Trial start time
    FeedbackTime:=View(pVAThreshdata%).Maxtime();
Newsflash("Begin Max Contraction in 5... 4... 3... 2... GO!",6,0,05,1); 'Trial start
    seconds(0,1);
    Yield(6);
'WaitTime:=6;
'Waiting%();
MVCendTime[i%]:=View(pVAThreshdata%).Maxtime();                                 'Track MVC Trial end time
FindMVC();                                                                'Find Average MVC of Trial
Newsflash("Well Done! Now rest.",85,0,05,1);                              'Trial rest duration
'seconds(0,1);
'WaitTime:=85;
'Waiting%();
next;
    SampleStop();
    Protocol$:="Stopped";
    var j%, pVAmvc%, ret%, fName$;
    pVAmvc% := FileNew(1);
    fName$ := View(pVAThreshdata%).FileName$(3);
for j%:= 0 to 2 do;

        View(pVAmvc%).print("%g",TrialMVCin[j%][:]);
        View(pVAmvc%).print("%g",TrialMVCout[j%][:]);
        View(pVAmvc%).print("%g",TrialBicepMVC[j%][:]);
    next;
    if (pVAmvc% >= 0) then
      ret% := View(pVAmvc%).FileSaveAs(print$("%s%s", fName$, "_MVC_FMandEMG.txt"), 1, 0, "Save analysis as...");
    if (ret% < 0) then
      View(pVAmvc%);
      FileClose(0, -1);
    else
      View(pVAmvc%);
        FileClose();
    endif;
    View(pVAThreshdata%).FileSaveAs(print$("%s%s", fName$, "__MVC"), -1);
    View(pVAThreshdata%);
    FileClose(0,-1);
    View(ForceFeedbackBarGraph%);
    FileClose(0,-1);
    View(resultViewH%);
    FileClose(0,-1);
    pVAThreshdata%:=-1;
endif;
return 1 'stay in the current toolbar
end;
func FindMVC()
var MVC, avgMVC, i%, BicepMVC;
const nMax% := 6000;           'MVC Trial bin length
var FxArray[nMax%], FyArray[nMax%], FzArray[nMax%], MxArray[nMax%], MyArray[nMax%], MzArray[nMax%];       'Arrays for forces and moments of each trial
var BicepArray[nMax%], TricepArray[nMax%];
'View(pVAdata%).ChanData(FxChan%, View(resultViewH%,FxChan%).[], MVCstartTime[TrialCount%]+6,MVCendTime[TrialCount%]);' update results waveform
'View(resultViewH%).YRange(FxChan%, View(resultViewH%).YLow(FxChan%), View(resultViewH%).YHigh(FxChan%));             ' "                     "
'View(resultViewH%).Draw();                                                                                           ' "                     "
FrontView(pVAdata%);
view(pVAdata%).ChanData(1, BicepArray, MVCstartTime[TrialCount%]+6, MVCendTime[TrialCount%]);
view(pVAdata%).ChanData(2, TricepArray, MVCstartTime[TrialCount%]+6, MVCendTime[TrialCount%]);
view(pVAdata%).ChanData(3, FxArray, MVCstartTime[TrialCount%]+6, MVCendTime[TrialCount%]); 'Get the arrays of forces and moments
view(pVAdata%).ChanData(4, FyArray, MVCstartTime[TrialCount%]+6, MVCendTime[TrialCount%]);
view(pVAdata%).ChanData(5, FzArray, MVCstartTime[TrialCount%]+6, MVCendTime[TrialCount%]);
view(pVAdata%).ChanData(8, MxArray, MVCstartTime[TrialCount%]+6, MVCendTime[TrialCount%]);
view(pVAdata%).ChanData(9, MyArray, MVCstartTime[TrialCount%]+6, MVCendTime[TrialCount%]);
view(pVAdata%).ChanData(10, MzArray, MVCstartTime[TrialCount%]+6, MVCendTime[TrialCount%]);

var ForceMomentIn[6000][6]; 'Turn vectors into single Force/Moment matrix
var BicepArrayFFS[6000][1];
ArrConst(ForceMomentIn[][0],FxArray);
ArrConst(ForceMomentIn[][1],FyArray);
ArrConst(ForceMomentIn[][2],FzArray);
ArrConst(ForceMomentIn[][3],MxArray);
ArrConst(ForceMomentIn[][4],MyArray);
ArrConst(ForceMomentIn[][5],MzArray);

'delta vec is a 1by6 coordinate transformation vector delta[]:=[dx, dy, dz, rotx, roty, rotz,]
'Intermediate values
'roll:=delta[3];
'pitch:=delta[4];
'yaw:=delta[5];

roll:=rotx;
pitch:=roty;
yaw:=rotz;

var MVCoutIndex%;
var MVCIndexEMG%;
var sr:=sin(roll);
var cr:=cos(roll);
var sp:=sin(pitch);
var cp:=cos(pitch);
var sy:=sin(yaw);
var cy:=cos(yaw);

var R[3][3];
var Px[3][3];

      'Calculate rotation matrix
      R[0][0]:=(cy*cp); R[0][1]:=(cy*sp*sr-sy*cr); R[0][2]:=(cy*sp*cr+sy*sr);
      R[1][0]:=(sy*cp); R[1][1]:=(sy*sp*sr+cy*cr); R[1][2]:=(sy*sp*cr-cy*sr);
      R[2][0]:=(-sp);   R[2][1]:=(cp*sr);          R[2][2]:=(cp*cr);

      'Translation matrix
      Px[0][0]:=(0);         Px[0][1]:=(-dz); Px[0][2]:=( dy);
      Px[1][0]:=( dz); Px[1][1]:=(0);         Px[1][2]:=(-dx);
      Px[2][0]:=(-dy); Px[2][1]:=( dx); Px[2][2]:=(0);
var B[3][3];
var J[6][6];
      'Jacobian
      ArrConst(J[0:3][0:3],R);     MATMul(B[][],Px,R);ArrConst(J[0:3][3:3],B);
      ArrConst(J[3:3][0:3],0);      ArrConst(J[3:3][3:3],R);

var Jtrans[6][6]; ArrConst(Jtrans[][],trans(J[][]));

for i%:=0 to nMax%-1 do
    'ForceMomentIn[i%][0:5] := [Fx[i%],Fy[i%],Fz[i%],Mx[i%],My[i%],Mz[i%]];
    var FMintrans[6]; ArrConst(FMintrans[],ForceMomentIn[i%][]);
    MatMul(ForceMomentOut[][i%],Jtrans,FMintrans);
next;
'get a running average of FMout and FMin over 0.5sec
var rolling;
for i%:=0 to nMax%-501 do
    ArrSum(ForceMomentOut[5][i%:500],smoothedMVCout[i%]);
    ArrSum(ForceMomentIn[i%:500][],smoothedMVCin[i%][]);
    ArrSum(BicepArray[i%:500],AvgBicep[i%]);
    rolling:=MVCstartTime[TrialCount%]+6.5+(i%/1000);
    BicepRMS[i%]:=ChanMeasure(1, 11, rolling, rolling+0.5);'view(pVAdata%).ChanMeasure(1, 11, rolling, rolling+0.5);
next;
MVCoutIndex%:=Min(smoothedMVCout[])+251; 'find location of MVC from smoothed data and adjust its location
MVCIndexEMG%:=Max(BicepRMS[])+251;

'MVCoutIndex%:=Max(smoothedMVCout[])+249; 'find location of MVC from smoothed data and adjust its location
ArrConst(TrialMVCin[TrialCount%][],ForceMomentIn[MVCoutIndex%][]); 'FMin data at MVC
ArrConst(TrialMVCout[TrialCount%][],ForceMomentOut[5][MVCoutIndex%]);'pretty sure I can just delete >>> view(resultViewH%).ChanMeasure(FxChan%,13,.1,7); 'measure from result view because filtered?
ArrConst(TrialBicepMVC[TrialCount%][],BicepRMS[MVCIndexEMG%]);
'----------------------------------------------------------------------------------------------------------------------
' I think calculating the RMS of MzIn might be the best way of doing later stuffs
'----------------------------------------------------------------------------------------------------------------------
'------------
    'TrialrmsMzIn:=ChanMeasure(MzChan%,11,MVCoutIndex%-.25,MVCoutIndex%+.25);' RMS Amplitude over 500ms of Mz at Trial MVC
    'ArrConst(RMSin[TrialCount%],TrialrmsMzIn);
    'if TrialCount% = 3 then
    '    ArrSum(RMSin[0:3],avgRMSin);
    'endif
'------------
'----------------------------------------------------------------------------------------------------------------------
BicepMVC:=0;
MVC:=0;
FxIn:=0;
FyIn:=0;
FzIn:=0;
MxIn:=0;
MyIn:=0;
MzIn:=0;
for i%:= 0 to TrialCount% do 'pretty sure I need to resize TrialMVC after each avgMVC is calculated?
    BicepMVC:=TrialBicepMVC[TrialCount%][0]+BicepMVC;
    MVCout:=TrialMVCout[TrialCount%][0]+MVCout;
    FxIn:=TrialMVCin[TrialCount%][0]+FxIn;
    FyIn:=TrialMVCin[TrialCount%][1]+FyIn;
    FzIn:=TrialMVCin[TrialCount%][2]+FzIn;
    MxIn:=TrialMVCin[TrialCount%][3]+MxIn;
    MyIn:=TrialMVCin[TrialCount%][4]+MyIn;
    MzIn:=TrialMVCin[TrialCount%][5]+MzIn;
next;
avgBicepMVC:=BicepMVC/(TrialCount%+1);
avgMVCout:=MVCout/(TrialCount%+1);
avgFxIn:=FxIn/(TrialCount%+1);
avgFyIn:=FyIn/(TrialCount%+1);
avgFzIn:=FzIn/(TrialCount%+1);
avgMxIn:=MxIn/(TrialCount%+1);
avgMyIn:=MyIn/(TrialCount%+1);
avgMzIn:=MzIn/(TrialCount%+1);

TrialCount%:=TrialCount%+1;
return 1;
end;
'----------------------------------------------------------------------------------------------------------------------
'----------------------------------------------------------------------------------------------------------------------
' The pVA Record Function (Runs after MVC is found)
'----------------------------------------------------------------------------------------------------------------------
'----------------------------------------------------------------------------------------------------------------------
func RECpVA%()
Protocol$:="REC_pVA"; 'set protocol to reflect that we are doing RECpVA% func
pVAButtonDisable%:=4;          ' sets the global varible to track button disables
pVAdata%:=FileNew(0,0);                 ' Open a new data file for sampling
if pVAdata%<0 then
    SampleStop();
  FileClose(-1,-1);
  pVAdata%:=FileNew(0,0);
    if pVAdata%<0 then
        Message("Unable to open new data file");Halt;
    endif;
endif;
SampleStart();
'-------------------------------------------------
' Calculate Cursor locations based on MVC data
'-------------------------------------------------
UpperEMGLimit:=(avgBicepMVC*1.05);
LowerEMGLimit:=(avgBicepMVC*0.95);

'UpperFxLimit:=(avgFxIn*1.025);
'LowerFxLimit:=(avgFxIn*0.975);
'UpperFyLimit:=(avgFyIn*1.025);
'LowerFyLimit:=(avgFyIn*0.975);
'UpperFzLimit:=(avgFzIn*1.025);
'LowerFzLimit:=(avgFzIn*0.975);
'UpperMzLimit:=(avgMzIn*1.025);
'LowerMzLimit:=(avgMzIn*0.975);

'UpperMzLimit:=(avgRMSin*1.025);
'LowerMzLimit:=(avgRMSin*0.975);
HCursorDelete(-1);              'Clear any existing cursors
'-------------------------------------------------
View(pVAdata%).XRange(-1);
View(pVAdata%).WindowVisible(1);
View(pVAdata%).DrawMode(-1,3);              'Set event draw mode to lines (3 for waveform)
View(pVAdata%).Window(0,0,60,100);            'Make data window right half of screen
'View(pVAdata%).FiltCalc(3, BinSize(1), highPassFilter[]); 'set the filter
'View(pVAdata%).ChanProcessAdd(1, 1, 0.01); 'Channel, 1=Smooth, Time constant (s)
'View(pVAdata%).ChanProcessAdd(1, 9, 0.01); 'Channel, 9=Median filter, Time constant (s)
ChanHide(31);
'-------------------------------------------------
'Force Feedback Bar Graph
'-------------------------------------------------
View(pVAdata%);
ForceFeedbackBarGraph%:=SetResult(1,1,0,"MVC Level","");
FrontView(ForceFeedbackBarGraph%);
'YAxisMode(2);'hide unit information
View(ForceFeedbackBarGraph%).XRange(0,1);
View(ForceFeedbackBarGraph%).YRange(1,0,(2*avgBicepMVC));      'Set Y range to match source waveform channel
View(ForceFeedbackBarGraph%).Window(60,0,100,100); 'Make bar graph window right 40% of screen
Colour(12,6);
HCursorNew(1,UpperEMGLimit);
HCursorNew(1,LowerEMGLimit);
FrontView(LogHandle());              'Bring the Log view to the front
FrontView(ForceFeedbackBarGraph%);          'Bring the bar graph results view to the front
FrontView(pVAdata%);                  'Bring the data view to the front
'var wait$;
'for TwitchTrial%:=0 to 10 do
'    wait$:="yes";
'Newsflash("Begin Max Contraction in 5... 4... 3... 2... GO!",6,0,05,1); 'Trial start
'    while wait$ = "yes" do
'        yield(1);
'    if (getTwitch% = 1) then
'        getTwitchAmp();
'        getTwitch%:=0;
'    endif;
'    if (getRestingTwitch% = 1) then
'        getTwitchAmp();
'        getRestingTwitch%:=0;
'        endif;
'        if
'    wend;

'Newsflash("Well Done! Now rest.",10,0,05,1);                              'Trial rest duration
'    yield(90);
''    if TwitchTrial% = 9 then
''        ArrSum(VA_Arr[0:10],avgVA);
''    SampleStop();
''    View(pVAdata%).FileSaveAs("", -1);
''    View(pVAdata%);
''    FileClose(0,-1);
''    pVAdata%:=-1;
''    pVAButtonDisable%:= 3; ' When finished recording allow cVA button
''    endif
'next;


return 1;
end;

'----------------------------------------------------------------------------------------------------------------------
' Find Interpolated Twitch
'----------------------------------------------------------------------------------------------------------------------
func getTwitchAmp()
var i%,PreTwitchAmp,MVCtwitchIndex%,MVCtwitchTime,RestingTwitchTime,TrialVA,RestingTwitchAmp,RestingTime;
var curTwitch[300];'
counter%:=0;
'if getTwitch% = 1 then
    Newsflash("Well Done! Now rest.",25,0,05,1);                              'Trial rest duration
    seconds(0,1);
    WaitTime:=25;
    Waiting%();
    PreTwitchAmp:=ChanMeasure(1,11,LastPulseTime - .15,LastPulseTime - .05)
    view(pVAdata%).ChanData(1, curTwitch, LastPulseTime + .05, LastPulseTime + .35); 'Fill array with 300ms of data around twitch
    MVCtwitchIndex%:=Max(curTwitch[]); 'find index of twitch max
    MVCtwitchTime:= (LastPulseTime + .05 + (MVCtwitchIndex%/1000)); 'convert index of twitch max to time in ms
    MVCtwitchAmp:=ChanMeasure(1,11,MVCtwitchTime-0.25,MVCtwitchTime+.025);' RMS Amplitude over 50ms of Mz at twitch max amp
    MVCtwitchPP:=MVCtwitchAmp - PreTwitchAmp;
    getTwitch%:=0;
    MVCtwitchArr[TwitchTrial%]:=MVCtwitchPP;
    MVCtwitchTimeArr[TwitchTrial%]:=MVCtwitchTime;

      SampleKey(t$);                                              'Trigger digitimer for resting twitch
            RestingTwitchTime:=View(pVAdata%).Maxtime();
 '           getRestingTwitch%:=1;                                        'Get resting state twitch data

'    return 1;
'endif;
'if getRestingTwitch% = 1 then
PreTwitchAmp:=ChanMeasure(1,2,RestingTwitchTime - .15,RestingTwitchTime - .1);
    yield(1);
    view(pVAdata%).ChanData(1, curTwitch, RestingTwitchTime + .05, RestingTwitchTime + .35); 'Fill array with 300ms of data around twitch
var RestTwitch[300]; 'Turn vectors into single Force/Moment matrix
ArrConst(RestTwitch[],curTwitch);
    RestingTwitchIndex%:=Max(RestTwitch[]); 'find index of twitch max
    RestingTime:= (RestingTwitchTime - .05 + (RestingTwitchIndex%/1000)); 'convert index of twitch max to time in ms
    RestingTwitch:=ChanMeasure(BicepEMGchan%,11,RestingTime-.025,RestingTime+.025);' RMS Amplitude over 50ms of Mz at twitch max amp
    RestingTwitchPP:=RestingTwitch - PreTwitchAmp;
    RestingTwitchArr[TwitchTrial%]:=RestingTwitchPP;
'    getRestingTwitch%:=0;
    'return RestingTwitchArr[];
    '--------------
    'Get VA% as (MVC_Twitch/Resting_Twitch)*100
    '--------------
    TrialVA:= MVCtwitchPP/RestingTwitchPP*100;
    VA_Arr[TwitchTrial%]:=TrialVA;
    'seconds(0,1);
    'WaitTime:=85;
    'Waiting%();
    Newsflash("Rest",85,0,05,1);
    TwitchTrial%+=1;
    if TwitchTrial% < 9 then
      Newsflash("Prepare for next contraction",5,0,05,1);
    endif;
    if TwitchTrial% = 9 then
      ArrSum(VA_Arr[0:10],avgVA);
      SampleStop();
      var fName$, fd%;
      fName$ := View(pVAdata%).FileName$(3);
      View(pVAdata%).FileSaveAs(print$("%s%s", fName$, "_pVA_Twitch_Data"), -1, 0, "Save analysis as...");
      fd% := FileNew(1);
      if (fd% < 0) then
        printlog("Could not open text file to save data, printing to log window.\n");
        endif;
      if (fd% < 0) then
        printlog("%sSTIM\t%sVAL\n", fName$, fName$);
      else
        View(fd%).print("%sSTIM\t%sVAL\n", fName$, fName$);
      endif;
      var j%;
      for j% := 0 to 9 do
          View(fd%).print("%d\t%f\n", i%, VA_Arr[i%]);
          View(fd%).print("%d\t%f\n", i%, MEPTimeArr[i%]);
        next;
      var ret%;
      if (fd% >= 0) then
        ret% := View(fd%).FileSaveAs(print$("%s%s", fName$, "_pVA_TwitchAmps.txt"), 1, 0, "Save analysis as...");
        if (ret% < 0) then
          View(fd%);
          FileClose(0, -1);
        else
          View(fd%);
          FileClose();
        endif;
    View(pVAdata%);
    FileClose(0,-1);
    pVAdata%:=-1;
    pVAButtonDisable%:= 3; ' When finished recording allow cVA button
    endif;
    return 1;'VA_Arr[];
endif;
end;
'----------------------------------------------------------------------------------------------------------------------'
'----------------------------------------------------------------------------------------------------------------------'
'----------------------------------------------------------------------------------------------------------------------'
'-------------------------------------The Cortical VA Toolbar Functions------------------------------------------------'
'----------------------------------------------------------------------------------------------------------------------'


'----------------------------------------------------------------------------------------------------------------------
' Find resting motor threshold
'----------------------------------------------------------------------------------------------------------------------
func LocateMT%()
Protocol$:="Locate MT";
TMSSetISI%(1, 0);
View(LogHandle());            'Make log view the current view
EditSelectAll();            'Select all text in log view
EditClear();              'Delete it
Window(0,80,100,100);          'Display it at the bottom of the screen
WindowVisible(1);            'Make it visbible

if (MwaveThreshdata%>0) then                      ' If there is already a data view open...
  View(MwaveThreshdata%);                       ' ...close it
  FileClose(0, -1);                             ' No point setting data% to 0...
endif;

MwaveThreshdata%:=FileNew(0,0);                 ' Open a new data file for sampling
if MwaveThreshdata%<0 then
    SampleStop();
  FileClose(-1,-1);
  MwaveThreshdata%:=FileNew(0,0);
    if MwaveThreshdata%<0 then
        Message("Unable to open new data file");Halt;
    endif;
endif;
View(MwaveThreshdata%).XRange(-1);
View(MwaveThreshdata%).WindowVisible(1);
View(MwaveThreshdata%).DrawMode(-1,3);              'Set event draw mode to lines (3 for waveform)
View(MwaveThreshdata%).Window(0,0,60,100);            'Make data window right half of screen
cScale := ChanScale(curChan%);
cOffset := ChanOffset(curChan%);
'View(MwaveThreshdata%).FiltCalc(3, BinSize(1), highPassFilter[]); 'set the filter
'View(MwaveThreshdata%).ChanProcessAdd(1, 1, 0.01); 'Channel, 1=Smooth, Time constant (s)
'View(MwaveThreshdata%).ChanProcessAdd(1, 9, 0.01); 'Channel, 9=Median filter, Time constant (s)
ChanHide(31);
ViewTrigger(TrigEventChan%, .1, .9, 1,1);

resultViewH%:=SetResult(5000, BinSize(1), -.1, "Filtered EMG", "s", ChanUnits$(1), "Time", "EMG-apb");
View(resultViewH%).DrawMode(1, 3);
View(resultViewH%).YRange(1, -0.250, 0.250);
View(resultViewH%).WindowVisible(1);
View(resultViewH%).CursorNew(XToBin(0));
View(resultViewH%).Window(0,0,60,80); 'Make EMG results graph window sit between log view and sampling data
Colour(12,6);
return 0;
end
proc updateLocation()
    View(MwaveThreshdata%).ChanData(1, View(resultViewH%,1).[], currentTrigTime-.1, currentTrigTime+.9);
end;
'func MwavePeakToPeak(startTime, endTime)
'  var minVal, maxVal, i%;
'    View(resultViewH%).Minmax(1, XToBin(startTime), XToBin(endTime), minVal, maxVal);
'    printlog("current peak to peak:", maxVal - minVal);
'    mWavePPArr[stimcount%]:= maxVal - minVal;
'    if(stimcount% > 2) then
'    ArrConst(View(MwaveBarGraph%).[:3],mWavePPArr[stimcount%-2:stimcount%]);                      'Set bar graph to new peak to peak value
'    DrawAll();  'update result views
'    endif
'  return maxVal - minVal;
'end;
func DoMTAnalyze%();
    var curPeakToPeak;
    view(resultViewH%); 'make sure we are looking at the results view, otherwise we get peak-to-peak of the same sampled data every time
    'yield(1); 'shouldn't need this because it is built into idle func
    curPeakToPeak:=MwavePeakToPeak(.03,.3);
if (stimcount% > 1) then
    PPdiff[stimcount%-2]:= curPeakToPeak - prevPeakToPeak;
    AnalyzeMwave(curPeakToPeak);
    return 0;
endif
end;
'----------------------------------------------------------------------------------------------------------------------
' Find resting motor threshold
'----------------------------------------------------------------------------------------------------------------------
func GetrMT%()
Protocol$:="rMT";
  getBestPestParams();
  doBestPest%:=1;
  rMT%:=0;
  TMSSetISI%(1, 0);
  fileRMTNo% += 1;
  SampleAutoName$(Print$("%s_RMT", subjectID$));
'return rMT;
return 0;
end
proc getBestPestParams()
    DlgCreate("BEST-PEST Criteria");
    DlgInteger(1, "Low bound", 0, 100);
    DlgInteger(2, "High bound", 0, 100);
    DlgInteger(3, "Spread", 0, 100);
    DlgReal(4, "Peak-to-peak threshold (mV)", 0, 100);
    DlgReal(5, "Response window start (sec)", 0, 1);
    DlgReal(6, "Response window end (sec)", 0, 1);
    DlgCheck(7, "Control Magstim");
    DlgShow(bestPestLowBound%, bestPestHighBound%, bestPestSpread%, bestPestThreshold, bestPestStartTime, bestPestEndTime, doAutoControl%);
    startBestpest(bestPestLowBound%, bestPestHighBound%);
    curStimOutput%:=Round(finalThreshold(bestPestSpread%));
    printlog("%10s%10s%10s%10s%15s%10s\n", "Stim", "CurOutput", "PtoP", "Success", "NextOutput", "rMT");
    printlog("%10d%10s%10s%10s%15d\n", 0, "--", "--", "--", 45);

    if (doAutoControl%) then
    DlgCreate("BEST-PEST Stop Criteria");
    DlgInteger(1, "Maximum number of stimuli", 0, 100);
    DlgCheck(2, "Stop if estimate repeats");
    DlgReal(3, "Inter-stimulus interval (sec)", 0, 20);
    DlgShow(maxOutputStim%, stopIfMTRepeats%, interStimulusInterval);
    TMSSetRemoteControl%(1);
    setTMSIntensity%(curStimOutput%, 1);
    armTMS%();
  endif;
end
'----------------------------------------------------------------------------------------------------------------------
' Do the cVA protocols after rMT is found
'----------------------------------------------------------------------------------------------------------------------
'func cVA%() ' Record Cortical VA
'Protocol$:="cVA";'set protocol to reflect that we are doing one of the cVA% funcs
'var ok%;
'    DlgCreate("Cortical VA Protocols");
'    DlgList(1,"Which Factor to Run?", "First|Second|Third|");
'    DlgList(2,"First Neuromuscular Factor"  , "Arm Posture|Cutaneous Reflex|Intracortical Facilitation|");
'    DlgList(3,"Second Neuromuscular Factor" , "Arm Posture|Cutaneous Reflex|Intracortical Facilitation|");
'    DlgList(4,"Third Neuromuscular Factor"  , "Arm Posture|Cutaneous Reflex|Intracortical Facilitation|");
'    DlgList(5,"Arm Posture to Use"  , "45deg|90deg|135deg|");
'    DlgList(6,"Cutaneous Reflex Interval to Use" , "40ms|70ms|100ms|");
'    DlgList(7,"Paired Pulse ISI to Use"  , "3ms|10ms|30ms|");
'    DlgButton(0,"Cancel");
'    DlgButton(1,"OK");
'    ok% := DlgShow(WhichOne%,FirstcVA%, SecondcVA%, ThirdcVA%,ArmPost%,ReflexInt%,ISInum%);
''    FirstcVAProtocol$:= DlgValue$(1);
''    SecondcVAProtocol$:= DlgValue$(2);
''    ThirdcVAProtocol$:= DlgValue$(3);
''    ArmPosture$:= DlgValue$(4);
''    ReflexInterval$:= DlgValue$(5);
''ISI$:= DlgValue$(6);
'
'Rand(PercentileToRun%[], 4, 1); 'Fill "array" with random integer between 1 and 4
'
'docase
'case    WhichOne% = 0 then
'    FirstcVAProtocol%();
'case    WhichOne% = 1 then
'    SecondcVAProtocol%();
'else
'    ThirdcVAProtocol%();
'endcase;
'
'FirstcVAProtocol$:= "Arm Posture";
'    SecondcVAProtocol$:= "Cutaneous Reflex";
'    ThirdcVAProtocol$:= "Intracortical Facilitation";
'    ArmPosture$:= "45deg";
'    ReflexInterval$:= "40ms";
'    ISI$:= "10ms";

'FirstcVAProtocol%();    'Do each protocol in order chosen
'SecondcVAProtocol%();
'ThirdcVAProtocol%();
'end;
func SetParameters%() ' Record Cortical VA
Protocol$:="cVA";'set protocol to reflect that we are doing one of the cVA% funcs
var ok%;
    DlgCreate("Cortical VA Protocols");
    DlgList(1,"Which Neuromuscular Factor?", "Arm Posture|Cutaneous Reflex|Intracortical Facilitation|");
    DlgInteger(2,"Intensity A"  , 1, 100);
    DlgInteger(3,"Intensity B"  , 0, 100);
    DlgInteger(4,"ISI" , 0, 200);
    DlgList(5,"Cutaneous Reflex Interval to Use" , "N/A|40ms|70ms|100ms|");
    DlgButton(0,"Cancel");
    DlgButton(1,"OK");
    ok% := DlgShow(WhichOne%, TMSintensityA, TMSintensityB, ISI, ReflexInt%);

TMSSetRemoteControl%(1);
setTMSIntensity%(TMSintensityA, 1);
setTMSIntensity%(TMSintensityB, 2);
TMSSetIsi%(1, ISI);
armTMS%();
TMSTriggerTMS%(1);
docase
case    WhichOne% = 0 then
    cVAprotocol$:="Arm Posture";
case    WhichOne% = 1 then
    cVAprotocol$:="Cutaneous Reflex";
else
    cVAprotocol$:="Paired Pulse";
    if ISI = 30 then
        SubProtocol$ := "30ms PP";
    endif;
    if ISI = 10 then
        SubProtocol$ := "10ms PP";
    endif;
endcase;
docase
case    ReflexInt% = 1 then
    PCSprotocol$:= "40ms Cutaneous Reflex";
case    ReflexInt% = 2 then
    PCSprotocol$:= "70ms Cutaneous Reflex";
case ReflexInt% = 3 then
    PCSprotocol$:= "100ms Cutaneous Reflex";
else
    PCSprotocol$:= "None";
endcase;
return 1;
end;
'----------------------------------------------------------------------------------------------------------------------
' Call the correct cVA function chosen
'----------------------------------------------------------------------------------------------------------------------
'func FirstcVAProtocol%()
'docase
'case FirstcVA% = 0 then ArmPosture%();
'case FirstcVA% = 1 then CutaneousReflex%();
'case FirstcVA% = 2 then PairedPulse%();
'endcase;
'end;
'func SecondcVAProtocol%()
'docase
'case SecondcVA% = 0 then ArmPosture%();
'case SecondcVA% = 1 then CutaneousReflex%();
'case SecondcVA% = 2 then PairedPulse%();
'endcase;
'end;
'func ThirdcVAProtocol%()
'docase
'case ThirdcVA% = 0 then ArmPosture%();
'case ThirdcVA% = 1 then CutaneousReflex%();
'case ThirdcVA% = 2 then PairedPulse%();
'
'endcase;
'end;
'----------------------------------------------------------------------------------------------------------------------
' Arm Posture cVA Function
'----------------------------------------------------------------------------------------------------------------------
'func ArmPosture%()
''var cVAtestAllComplete%:=0; 'reset that none of the %MVC trials have been run
'var ok%;
'
'cVAProtocol$:="Arm Posture";
''Manually set magstim amplitude and ISI if needed
'    DlgCreate("Manually Set TMS Intensity?");
'    DlgInteger(1,"Intensity A"  , 1, 100);
'    DlgInteger(2,"Intensity B"  , 0, 100);
'    DlgInteger(3,"ISI" , 0, 200);
'    DlgButton(0,"Cancel");
'    DlgButton(1,"OK");
'    ok% := DlgShow(TMSintensityA, TMSintensityB, ISI);
'    'TMSintensityA:= DlgValue(1);
'    'TMSintensityB:= DlgValue(2);
'    'ISI:= DlgValue(3);
'
'setTMSIntensity%(TMSintensityA, 1);
'setTMSIntensity%(TMSintensityB, 2);
'TMSSetIsi%(1, ISI);
'
'docase                          'Message to ensure patient's arm is in the correct posture
'case ArmPost% = 0 then
'    Message(Print$("Please check that patient's arm is at a 45deg angle"));
'case ArmPost% = 1 then
'    Message(Print$("Please check that patient's arm is at a 90deg angle"));
'case ArmPost% = 2 then
'    Message(Print$("Please check that patient's arm is at a 135deg angle"));
'endcase;
'
'while cVAtestAllComplete% = 0 do 'while loop ends after all four tests
'    if whichcVAtest%[0] = 1 AND cVAtestZeroComplete% = 0 then
'        SubProtocol$:="cVAtestZero";
'        cVAtestZero%();
'    endif;
'    if whichcVAtest%[0] = 2 AND cVAtestFiftyComplete% = 0 then
'        SubProtocol$:="cVAtestFifty";
'        cVAtestFifty%();
'    endif;
'    if whichcVAtest%[0] = 3 AND cVAtestSeventyComplete% = 0 then
'        SubProtocol$:="cVAtestSeventy";
'        cVAtestSeventy%();
'    endif;
'    if whichcVAtest%[0] = 4 AND cVAtestOnehundredComplete% = 0 then
'        SubProtocol$:="cVAtestOnehundred";
'        cVAtestOnehundred%();
'    endif;
'wend
'return 1
'end;
''----------------------------------------------------------------------------------------------------------------------
'' Cutaneous Reflex cVA Function
''----------------------------------------------------------------------------------------------------------------------
'func CutaneousReflex%()
''var cVAtestAllComplete%:=0; 'reset that none of the %MVC trials have been run
'var whichcVAtest%[1];
'var ok%;
'cVAProtocol$:="Cutaneous Reflex";
''Manually set magstim amplitude and ISI if needed
'    DlgCreate("Manually Set TMS Intensity?");
'    DlgInteger(1,"Intensity A"  , 1, 100);
'    DlgInteger(2,"Intensity B"  , 1, 100);
'    DlgInteger(3,"ISI" , 0, 200);
'    DlgButton(0,"Cancel");
'    DlgButton(1,"OK");
'    ok% := DlgShow(TMSintensityA, TMSintensityB, ISI);
'    'TMSintensityA:= DlgValue(1);
'    'TMSintensityB:= DlgValue(2);
'    'ISI:= DlgValue(3);
'
'setTMSIntensity%(TMSintensityA, 1);
'setTMSIntensity%(TMSintensityB, 2);
'TMSSetIsi%(1, ISI);
'
'docase                          'Message to ensure digitimer intensity set correctly
'case ReflexInt% = 0 then
'    Message(Print$("Please check that the Digitimer intensity is set to 80% pain threshold"));
'    cVAprotocol$:="40ms Cutaneous Reflex"
'case ReflexInt% = 1 then
'    Message(Print$("Please check that the Digitimer intensity is set to 80% pain threshold"));
'    cVAprotocol$:="70ms Cutaneous Reflex"
'case ReflexInt% = 2 then
'    Message(Print$("Please check that the Digitimer intensity is set to 80% pain threshold"));
'    cVAprotocol$:="100ms Cutaneous Reflex"
'endcase;
'
'while cVAtestAllComplete% = 0 do 'while loop ends after all four tests
'    Rand(whichcVAtest%[], 3, 1); 'Fill "array" with random integer between 1 and 4
'    if whichcVAtest%[0] = 1 AND cVAtestZeroComplete% = 0 then
'        SubProtocol$:="cVAtestZero";
'        cVAtest();
'    endif;
'    if whichcVAtest%[0] = 2 AND cVAtestFiftyComplete% = 0 then
'        SubProtocol$:="cVAtestFifty";
'        cVAtest();
'    endif;
'    if whichcVAtest%[0] = 3 AND cVAtestSeventyComplete% = 0 then
'        SubProtocol$:="cVAtestSeventy";
'        cVAtest();
'    endif;
'    if whichcVAtest%[0] = 4 AND cVAtestOnehundredComplete% = 0 then
'        SubProtocol$:="cVAtestOnehundred";
'        cVAtest();
'    endif;
'wend
'return 1
'end;
'----------------------------------------------------------------------------------------------------------------------
' Paired Pulse cVA Function
'----------------------------------------------------------------------------------------------------------------------
'func PairedPulse%()
'var cVAtestAllComplete%:=0; 'reset that none of the %MVC trials have been run
'var whichcVAtest%[1];
'var ok%;
'cVAProtocol$:="Paired Pulse";
''Manually set magstim amplitude and ISI if needed
'    DlgCreate("Manually Set TMS Intensity?");
'    DlgInteger(1,"Intensity A"  , 1, 100);
'    DlgInteger(2,"Intensity B"  , 1, 100);
'    DlgInteger(3,"ISI" , 0, 200);
'    DlgButton(0,"Cancel");
'    DlgButton(1,"OK");
'    ok% := DlgShow(TMSintensityA, TMSintensityB, ISI);
'    'TMSintensityA:= DlgValue(1);
'    'TMSintensityB:= DlgValue(2);
'    'ISI:= DlgValue(3);
'
'setTMSIntensity%(TMSintensityA, 1);
'setTMSIntensity%(TMSintensityB, 2);
'TMSSetIsi%(1, ISI);
'
'while cVAtestAllComplete% = 0 do 'while loop ends after all four tests
'    Rand(whichcVAtest%[], 4, 1); 'Fill "array" with random integer between 1 and 4
'    if whichcVAtest%[0] = 1 AND cVAtestZeroComplete% = 0 then
'        SubProtocol$:="cVAtestZero";
'        cVAtestZero%();
'    endif;
'    if whichcVAtest%[0] = 2 AND cVAtestFiftyComplete% = 0 then
'        SubProtocol$:="cVAtestFifty";
'        cVAtestFifty%();
'    endif;
'    if whichcVAtest%[0] = 3 AND cVAtestSeventyComplete% = 0 then
'        SubProtocol$:="cVAtestSeventy";
'        cVAtestSeventy%();
'    endif;
'    if whichcVAtest%[0] = 4 AND cVAtestOnehundredComplete% = 0 then
'        SubProtocol$:="cVAtestOnehundred";
'        cVAtestOnehundred%();
'    endif;
'wend
'return 1
'end;
func cVAtestZero%()
Protocol$:="cVA";
SubProtocol$:="cVAtestZero";
cVAdata%:=FileNew(0,0);                 ' Open a new data file for sampling
if cVAdata%<0 then
    SampleStop();
  FileClose(-1,-1);
  cVAdata%:=FileNew(0,0);
    if cVAdata%<0 then
        Message("Unable to open new data file");Halt;
    endif;
endif;
SampleStart();
'-------------------------------------------------------
' Calculate Cursor locations based on MVC data and %MVC
'-------------------------------------------------------
UpperEMGLimit:=(avgBicepMVC*0.1);
LowerEMGLimit:=(avgBicepMVC*0);
HCursorDelete(-1);              'Clear any existing cursors
'-------------------------------------------------
View(cVAdata%).XRange(-1);
View(cVAdata%).WindowVisible(1);
View(cVAdata%).DrawMode(-1,3);              'Set event draw mode to lines (3 for waveform)
View(cVAdata%).Window(0,0,60,100);            'Make data window right half of screen
ChanHide(31);
'-------------------------------------------------
'Force Feedback Bar Graph
'-------------------------------------------------
View(cVAdata%);
ForceFeedbackBarGraph%:=SetResult(1,1,0,"Force Level","");
FrontView(ForceFeedbackBarGraph%);
View(ForceFeedbackBarGraph%).XRange(0,1);
View(ForceFeedbackBarGraph%).YRange(1,0,0.5*avgBicepMVC);      'Set Y range to match source waveform channel
View(ForceFeedbackBarGraph%).Window(60,0,100,100); 'Make bar graph window right 40% of screen
Colour(12,6);
HCursorNew(1,UpperEMGLimit);
HCursorNew(1,LowerEMGLimit);
FrontView(LogHandle());              'Bring the Log view to the front
FrontView(ForceFeedbackBarGraph%);          'Bring the bar graph results view to the front
FrontView(cVAdata%);

if(View(cVAdata%).Maxtime() - paftn >= 90) then
    ToolbarText("Begin Resting Contraction");
    Sound("SS")
endif;

'if waitforTMS% = 5 then
''    SampleStop();
''    View(cVAdata%).FileSaveAs("cVA_atRest_", -1);
''    View(cVAdata%);
''    FileClose(0,-1);
''    cVAdata%:=-1;
''    waitforTMS%:= 0;
''    endif;
return 1;
end;
'-----------------------
'
'   50
'-----------------------
func cVAtestFifty%()
Protocol$:="cVA";
SubProtocol$:="cVAtestFifty";
cVAdata%:=FileNew(0,0);                 ' Open a new data file for sampling
if cVAdata%<0 then
    SampleStop();
  FileClose(-1,-1);
  cVAdata%:=FileNew(0,0);
    if cVAdata%<0 then
        Message("Unable to open new data file");Halt;
    endif;
endif;
SampleStart();
'-------------------------------------------------------
' Calculate Cursor locations based on MVC data and %MVC
'-------------------------------------------------------
UpperEMGLimit:=(avgBicepMVC*0.55);
LowerEMGLimit:=(avgBicepMVC*0.45);
HCursorDelete(-1);              'Clear any existing cursors
'-------------------------------------------------
View(cVAdata%).XRange(-1);
View(cVAdata%).WindowVisible(1);
View(cVAdata%).DrawMode(-1,3);              'Set event draw mode to lines (3 for waveform)
View(cVAdata%).Window(0,0,60,100);            'Make data window right half of screen
ChanHide(31);
'-------------------------------------------------
'Force Feedback Bar Graph
'-------------------------------------------------
View(cVAdata%);
ForceFeedbackBarGraph%:=SetResult(1,1,0,"Force Level","");
FrontView(ForceFeedbackBarGraph%);
View(ForceFeedbackBarGraph%).XRange(0,1);
View(ForceFeedbackBarGraph%).YRange(1,0,1*avgBicepMVC);      'Set Y range to match source waveform channel
View(ForceFeedbackBarGraph%).Window(60,0,100,100); 'Make bar graph window right 40% of screen
Colour(12,6);
HCursorNew(1,UpperEMGLimit);
HCursorNew(1,LowerEMGLimit);
FrontView(LogHandle());              'Bring the Log view to the front
FrontView(ForceFeedbackBarGraph%);          'Bring the bar graph results view to the front
FrontView(cVAdata%);

if(View(cVAdata%).Maxtime() - paftn >= 5) then
    ToolbarText("Begin 50% Contraction");
    Sound("SS")
endif;

'if waitforTMS% = 5 then
''    SampleStop();
''    View(cVAdata%).FileSaveAs("cVA_at50_", -1);
''    View(cVAdata%);
''    FileClose(0,-1);
''    cVAdata%:=-1;
''    waitforTMS% := 0;
''    endif;
return 1;
end;
'-----------------------
'
'   70
'-----------------------
func cVAtestSeventy%()
Protocol$:="cVA";
SubProtocol$:="cVAtestSeventy";
cVAdata%:=FileNew(0,0);                 ' Open a new data file for sampling
if cVAdata%<0 then
    SampleStop();
  FileClose(-1,-1);
  cVAdata%:=FileNew(0,0);
    if cVAdata%<0 then
        Message("Unable to open new data file");Halt;
    endif;
endif;
SampleStart();
'-------------------------------------------------------
' Calculate Cursor locations based on MVC data and %MVC
'-------------------------------------------------------
UpperEMGLimit:=(avgBicepMVC*0.80);
LowerEMGLimit:=(avgBicepMVC*0.70);
HCursorDelete(-1);              'Clear any existing cursors
'-------------------------------------------------
View(cVAdata%).XRange(-1);
View(cVAdata%).WindowVisible(1);
View(cVAdata%).DrawMode(-1,3);              'Set event draw mode to lines (3 for waveform)
View(cVAdata%).Window(0,0,60,100);            'Make data window right half of screen
ChanHide(31);
'-------------------------------------------------
'Force Feedback Bar Graph
'-------------------------------------------------
View(cVAdata%);
ForceFeedbackBarGraph%:=SetResult(1,1,0,"Force Level","");
FrontView(ForceFeedbackBarGraph%);
View(ForceFeedbackBarGraph%).XRange(0,1);
View(ForceFeedbackBarGraph%).YRange(1,0,1.5*avgBicepMVC);      'Set Y range to match source waveform channel
View(ForceFeedbackBarGraph%).Window(60,0,100,100); 'Make bar graph window right 40% of screen
Colour(12,6);
HCursorNew(1,UpperEMGLimit);
HCursorNew(1,LowerEMGLimit);
FrontView(LogHandle());              'Bring the Log view to the front
FrontView(ForceFeedbackBarGraph%);          'Bring the bar graph results view to the front
FrontView(cVAdata%);

if(View(cVAdata%).Maxtime() - paftn >= 90) then
    ToolbarText("Begin 70% Contraction");
    Sound("SS")
endif;

'if waitforTMS% = 5 then
''    SampleStop();
''    View(cVAdata%).FileSaveAs("cVA_at70_", -1);
''    View(cVAdata%);
''    FileClose(0,-1);
''    cVAdata%:=-1;
''    waitforTMS% := 0;
''    endif;
return 1;
end;
'-----------------------
'
'   100
'-----------------------
func cVAtestOnehundred%()
Protocol$:="cVA";
SubProtocol$:="cVAtestOnehundred";
cVAdata%:=FileNew(0,0);                 ' Open a new data file for sampling
if cVAdata%<0 then
    SampleStop();
  FileClose(-1,-1);
  cVAdata%:=FileNew(0,0);
    if cVAdata%<0 then
        Message("Unable to open new data file");Halt;
    endif;
endif;
SampleStart();
'-------------------------------------------------------
' Calculate Cursor locations based on MVC data and %MVC
'-------------------------------------------------------
UpperEMGLimit:=(avgBicepMVC*1.05);
LowerEMGLimit:=(avgBicepMVC*0.95);
HCursorDelete(-1);              'Clear any existing cursors
'-------------------------------------------------
View(cVAdata%).XRange(-1);
View(cVAdata%).WindowVisible(1);
View(cVAdata%).DrawMode(-1,3);              'Set event draw mode to lines (3 for waveform)
View(cVAdata%).Window(0,0,60,100);            'Make data window right half of screen
ChanHide(31);
'-------------------------------------------------
'Force Feedback Bar Graph
'-------------------------------------------------
View(cVAdata%);
ForceFeedbackBarGraph%:=SetResult(1,1,0,"Force Level","");
FrontView(ForceFeedbackBarGraph%);
View(ForceFeedbackBarGraph%).XRange(0,1);
View(ForceFeedbackBarGraph%).YRange(1,0,1.5*avgBicepMVC);      'Set Y range to match source waveform channel
View(ForceFeedbackBarGraph%).Window(60,0,100,100); 'Make bar graph window right 40% of screen
Colour(12,6);
HCursorNew(1,UpperEMGLimit);
HCursorNew(1,LowerEMGLimit);
FrontView(LogHandle());              'Bring the Log view to the front
FrontView(ForceFeedbackBarGraph%);          'Bring the bar graph results view to the front
FrontView(cVAdata%);

if(View(cVAdata%).Maxtime() - paftn >= 90) then
    ToolbarText("Begin Maximum Contraction");
    Sound("SS")
endif;

'if waitforTMS% = 5 then
''    SampleStop();
''    View(cVAdata%).FileSaveAs("cVA_at100_", -1);
''    View(cVAdata%);
''    FileClose(0,-1);
''    cVAdata%:=-1;
''    waitforTMS% := 0;
''    endif;
return 1;
end;
'-------------------------------------------------------------------------------------------
'
'---------------------------------------------------------------------------------------------
func cVAtestAll%()
Protocol$:="cVA";
SubProtocol$:="cVAtestAll";
cVAdata%:=FileNew(0,0);                 ' Open a new data file for sampling
if cVAdata%<0 then
    SampleStop();
  FileClose(-1,-1);
  cVAdata%:=FileNew(0,0);
    if cVAdata%<0 then
        Message("Unable to open new data file");Halt;
    endif;
endif;
SampleStart();
'-------------------------------------------------------
' Calculate Cursor locations based on MVC data and %MVC
'-------------------------------------------------------
Randomize%();
HCursorDelete(-1);              'Clear any existing cursors
'-------------------------------------------------
View(cVAdata%).XRange(-1);
View(cVAdata%).WindowVisible(1);
View(cVAdata%).DrawMode(-1,3);              'Set event draw mode to lines (3 for waveform)
View(cVAdata%).Window(0,0,60,100);            'Make data window right half of screen
ChanHide(31);
'-------------------------------------------------
'Force Feedback Bar Graph
'-------------------------------------------------
View(cVAdata%);
ForceFeedbackBarGraph%:=SetResult(1,1,0,"Target Force Level","");
FrontView(ForceFeedbackBarGraph%);
View(ForceFeedbackBarGraph%).XRange(0,1);
View(ForceFeedbackBarGraph%).YRange(1,0,2*UpperEMGLimit);      'Set Y range to match source waveform channel
View(ForceFeedbackBarGraph%).YAxisMode(11);      'Hide all Y axis information
View(ForceFeedbackBarGraph%).Window(60,0,100,100); 'Make bar graph window right 40% of screen
Colour(12,6);
HCursorNew(1,UpperEMGLimit);
HCursorNew(1,LowerEMGLimit);
FrontView(LogHandle());              'Bring the Log view to the front
FrontView(ForceFeedbackBarGraph%);          'Bring the bar graph results view to the front
FrontView(cVAdata%);


return 1;
end;
'----------------------------------------------------------------------------------------------------------------------
' Get bicep/tricep MEP ratios
'----------------------------------------------------------------------------------------------------------------------
func getMEP%()
var i%,BicepPreMEP,TricepPreMEP,MEPIndex%,MEPTime,TrialVA,BicepMEP,TricepMEP;
var curMEP[300];
if waitforTMS% = 3 then
Newsflash("Well Done! Now rest. 5 more sets to go!",110,0,05,1);
endif;
if waitforTMS% = 7 then
Newsflash("Well Done! Now rest. 4 more sets to go!",110,0,05,1);
endif;
if waitforTMS% = 11 then
Newsflash("Well Done! Now rest. 3 more sets to go!",110,0,05,1);
endif;
if waitforTMS% = 15 then
Newsflash("Well Done! Now rest. 2 more sets to go!",110,0,05,1);
endif;
if waitforTMS% = 19 then
Newsflash("Well Done! Now rest. 1 more sets to go!",110,0,05,1);
endif;
'seconds(0);
'WaitTime:=75;
'DlgAllow(1023,Waiting%);
'Waiting%();
Newsflash("Prepare for next contraction",5,0,05,1);
'if updateMEP% = 1 then
    BicepPreMEP:=view(cVAdata%).ChanMeasure(1,11,LastStimTime - .15,LastStimTime - .05);
    TricepPreMEP:=(view(cVAdata%).ChanMeasure(2,11,LastStimTime - .15,LastStimTime - .05)+1);
    PreMEParray[TrialCount%]:=BicepPreMEP/TricepPreMEP;
    view(pVAdata%).ChanData(2, curMEP, LastStimTime + .05, LastStimTime + .35); 'Fill array with 300ms of data around twitch
    MEPIndex%:=Max(curMEP[]); 'find index of twitch max
    MEPTime:= (LastStimTime + .05 + (MEPIndex%/1000)); 'convert index of twitch max to time in ms
    BicepMEP:=ChanMeasure(1,11,MEPTime-.025,MEPTime+.025);' RMS Amplitude over 50ms of Bicep EMG at MEP max amp
    TricepMEP:=(ChanMeasure(2,11,MEPTime-.025,MEPTime+.025)+1);' RMS Amplitude over 50ms of Bicep EMG at MEP max amp
    NormalizedMEP:=BicepMEP/TricepMEP;
    NormedMEPArr[TrialCount%]:=NormalizedMEP;
    MEPTimeArr[TrialCount%]:=MEPTime;
    paftn:=view(cVAdata%).MaxTime();
    Randomize%();
    waitforTMS%+=1;
    return 1
'endif;
end;
func Randomize%()
if waitforTMS% = 23 then
    Finish%();
    'waitforTMS% = 0;
endif;
'
rNum%:= round(rand()*3)+1;
docase
  case rNum% = 1 then
    if numZero% < 6 then
      UpperEMGLimit:=(avgBicepMVC*0.05);
        LowerEMGLimit:=(avgBicepMVC*0);
        View(ForceFeedbackBarGraph%).HCursorDelete(-1);
        View(ForceFeedbackBarGraph%).YRange(1,0,2*UpperEMGLimit);
        View(ForceFeedbackBarGraph%).HCursorNew(1,UpperEMGLimit);
        View(ForceFeedbackBarGraph%).HCursorNew(1,LowerEMGLimit);
        'view(cVAdata%).CursorNew
      numZero%+=1;
    else Randomize%();
    endif;
  case rNum% = 2 then
    if numFifty% < 6 then
      UpperEMGLimit:=(avgBicepMVC*0.55);
        LowerEMGLimit:=(avgBicepMVC*0.45);
        View(ForceFeedbackBarGraph%).HCursorDelete(-1);
        View(ForceFeedbackBarGraph%).YRange(1,0,2*UpperEMGLimit);
        View(ForceFeedbackBarGraph%).HCursorNew(1,UpperEMGLimit);
        View(ForceFeedbackBarGraph%).HCursorNew(1,LowerEMGLimit);
      numFifty%+=1;
    else Randomize%();
    endif;
  case rNum% = 3 then
    if numSeventy% < 6 then
      UpperEMGLimit:=(avgBicepMVC*0.80);
        LowerEMGLimit:=(avgBicepMVC*0.70);
        View(ForceFeedbackBarGraph%).HCursorDelete(-1);
        View(ForceFeedbackBarGraph%).YRange(1,0,2*UpperEMGLimit);
        View(ForceFeedbackBarGraph%).HCursorNew(1,UpperEMGLimit);
        View(ForceFeedbackBarGraph%).HCursorNew(1,LowerEMGLimit);
      numSeventy%+=1;
    else Randomize%();
    endif;
  case rNum% = 4 then
    if numOneHundred% < 6 then
      UpperEMGLimit:=(avgBicepMVC*1.075);
        LowerEMGLimit:=(avgBicepMVC*0.975);
        View(ForceFeedbackBarGraph%).HCursorDelete(-1);
        View(ForceFeedbackBarGraph%).YRange(1,0,2*UpperEMGLimit);
        View(ForceFeedbackBarGraph%).HCursorNew(1,UpperEMGLimit);
        View(ForceFeedbackBarGraph%).HCursorNew(1,LowerEMGLimit);
      numOneHundred%+=1;
    else Randomize%();
    endif;
endcase;
end;
func Marking%()
'Function for tracking the percent MVC that each randomized trial occurs at'
docase
  case rNum% = 1 then
    Mark 1;
  case rNum% = 2 then
    Mark 50;
  case rNum% = 3 then
    Mark 75;
  case rNum% = 4 then
    Mark 100;
  else
    Mark 0;
endcase;
end;
func Back%()                  ' Go back to previouse toolbar (or exits script if on outermost toolbar)
return 0                    ' Just leaves the current one
end;

'*********************************************************
'*********************************************************
'BEST PEST

var maxStim% := 1000;

var    nrStimulus%;
var    Staerken%[1000];
var    Erfolge%[1000];
var    sigma;
var    relSigmaFinal;

proc insertStimulus(Staerke%, Erfolg%)
  nrStimulus% := nrStimulus%+1;
  Staerken%[nrStimulus%]:=Staerke%;
  Erfolge%[nrStimulus%]:=Erfolg%;
end;

proc startBestpest(LowBound,HighBound)
  nrStimulus%:=0;
  insertStimulus(Round(LowBound),0);
  insertStimulus(Round(HighBound),1);
end;

func sureln(x)
  if (x<1.0e-100) then
    return -12000;
  else
    return(Ln(x));
  endif;
  return Ln(x);
end;

func CuGauss(x, mue, sigma)
var Wurzel2:=1.414213562;
var   xtrans,t,z,ans,hilf,hilf1,hilf2, hilf3,hilf4,erfcc;

   if sigma<1.0e-10 then
     if x<mue then return 0.0 else return 1.0 endif;
     printlog("Error in CuGauss\n");
     return -1;
   endif;
   xtrans:=(x-mue)/(wurzel2*sigma);
   z := Abs(xtrans);
   if z>50 then
     if xtrans>0 then return 1.0 else return 0.0 endif;
     printlog("Error in CuGauss\n");
     return -1;
   endif;
   t := 1.0/(1.0+0.5*z);
   hilf:=(-0.82215223+t*0.17087277);
   hilf1:=(1.48851587+t*hilf);
   hilf2:=(-1.13520398+t*hilf1);
   hilf3:=(0.27886807+t*hilf2);
   hilf4:=(-0.18628806+t*hilf3);
   ans := t*Exp(-z*z-1.26551223+t*(1.00002368+
      t*(0.37409196+t*(0.09678418+t*hilf4))));
   if (xtrans >= 0.0) then
    erfcc := ans;
   else
    erfcc := 2.0-ans;
   endif;
   return (0.5*(2.0-erfcc));
end;

func funcfinal(x);
var L;
var i;
var xsigma;
  L:=0.0;
  xsigma:=relSigmaFinal*x/100;
  for i:=1 to nrStimulus% do
    if Erfolge%[i]=1 then
      L:=L+sureln(1-CuGauss(x,Staerken%[i],xsigma))
    else
      L:=L+sureln((CuGauss(x,Staerken%[i],xsigma)));
    endif;
  next;

  return -L;
end;

func sign(a,b)
      if (b > 0.0) then return  (Abs(a)) else return(-Abs(a)) endif;
end;


func brent(ax,bx,cx,tol, &xmin)
var   itmax%:=100;
var   cgold:=0.3819660;
var   zeps:=1.0e-10;
var   a,b,d,e,etemp;
var   fu,fv,fw,fx;
var   iter%;
var   p,q,r,tol1,tol2;
var   u,v,w,x,xm;

   if ax < cx then a := ax else a := cx endif;
   if ax > cx then b := ax else b := cx endif;
   v := bx;
   w := v;
   x := v;
   e := 0.0;
   fx := funcfinal(x);
   fv := fx;
   fw := fx;
   for iter% := 1 to itmax% do
      xm := 0.5*(a+b);
      tol1 := tol*Abs(x)+zeps;
      tol2 := 2.0*tol1;
      if (Abs(x-xm) <= (tol2-0.5*(b-a))) then
        xmin := x;
        return (fx);
      endif;
      if (Abs(e) > tol1) then
         r := (x-w)*(fx-fv);
         q := (x-v)*(fx-fw);
         p := (x-v)*q-(x-w)*r;
         q := 2.0*(q-r);
         if (q > 0.0) then  p := -p endif;
         q := Abs(q);
         etemp := e;
         e := d;
         if((Abs(p) >= Abs(0.5*q*etemp)) or (p <= q*(a-x))
            or (p >= q*(b-x))) then
            if (x >= xm)  then e := a-x else e := b-x endif;
            d := cgold*e;
         else
           d := p/q;
           u := x+d;
           if (((u-a) < tol2) or ((b-u) < tol2)) then d := sign(tol1,xm-x) endif;
         endif;
      endif;
      if (Abs(d) >= tol1)  then u := x+d else u := x+sign(tol1,d) endif;
      fu := funcfinal(u);
      if (fu <= fx)  then
         if (u >= x)  then a := x else b := x endif;
         v := w;
         fv := fw;
         w := x;
         fw := fx;
         x := u;
         fx := fu
      else
         if (u < x)  then a := u else b := u endif;
         if ((fu <= fw) or (w = x))  then
            v := w;
            fv := fw;
            w := u;
            fw := fu
         else
          if ((fu <= fv) or (v = x) or (v = 2)) then
            v := u;
            fv := fu
           endif;
         endif;
      endif;
   next;
   'printlog("pause in routine BRENT - too many iterations");
   xmin := x;
   return (fx);
end;

func finalThreshold(relSigma)
var ff[101];
var    mini%,mini2%,i%;
var    aktff,minff,thest;
'  finalThreshold:=-1.0e38;
  relSigmaFinal:=relSigma;
  minff:=1.0e38;
  mini%:=0;
  for i%:=1 to 100 do
    aktff:=funcfinal(i%);
    ff[i%]:=aktff;
    if Abs(aktff-minff)<1.0e-7 then
      mini2%:=i%;
    else
      if aktff<minff then
        minff:=aktff;
        mini%:=i%;
        mini2%:=i%;
    endif;
   endif;
  next;
  if mini%<>mini2% then
    return(0.5*(mini%+mini2%));
  else
    brent(mini%-1,mini%,mini%+1,1.0e-7,thest);
    return(thest);
  endif;
end;

proc ANALYZErMT(curPeakToPeak)
    if (curPeakToPeak > bestPestThreshold) then
      Colour(12, 14);
    else
      Colour(12, 16);
    endif;

    'numStim%+=1;
    if (curPeakToPeak > bestPestThreshold) then
      insertStimulus(curStimOutput%, 1);
    else
      insertStimulus(curStimOutput%, 0);
    endif;
    var lastStimOutput%;
    lastStimOutput%:=curStimOutput%;
    curStimOutput%:=Round(finalThreshold(bestPestSpread%));
    printBESTPEST(lastStimOutput%, curPeakToPeak, curPeakToPeak>bestPestThreshold, curStimOutput%);
    if (curStimOutput%=lastStimOutput% or numStim%>=maxOutputStim%) then
      printlog("BEST-PEST rMT: %d\n", curStimOutput%);
      rMT%:=curStimOutput%;
      doAutoControl%:=0;
    endif;
end;
proc printBESTPEST(curOutput%, peakToPeak, succ%, nextOutput%)
  if (numStim%<=3) then
    printlog("%10d|%10d|%10.3f|%10d|%15d\n", numStim%, curOutput%, peakToPeak, succ%, nextOutput%);
  else
    printlog("%10d|%10d|%10.3f|%10d|%15d|", numStim%, curOutput%, peakToPeak, succ%, nextOutput%);
    printlog("%10d\n", curOutput%);
  endif;

end
func DoAnalyze%()
  var curPeakToPeak;
  'if (doHPFilter%) then
  '  removeDrift%();
  'endif;
  'if (do60CycleFilter%) then
  '  remove60cycle();
  'endif;
  View(resultViewH%);
  'if (doTMSArtifactFilter%) then
  '  FILTERsubtractExp(1, BinToX(Cursor(FILTERexpFilterCursorStart%)), BinToX(Cursor(FILTERexpFilterCursorEnd%)));
  'endif;
  curPeakToPeak:=peakToPeak(bestpestStartTime, bestpestEndTime);
  return 0;
end;
func peakToPeak(startTime, endTime)
  var minVal, maxVal;
  View(resultViewH%).Minmax(1, XToBin(startTime), XToBin(endTime), minVal, maxVal);
'  printlog("peak to peak:", maxVal - minVal);
  return maxVal - minVal;
end;
'***************************************************
'***************************************************
'TMS controls
func getInterStimulusInterval()
  return interStimulusIntervalMin + Rand()*jitter;
end;

func checkTMSStatus%()
  if (TMSwhichMagstim% = TMSMAGSTIM200%) then
    TMSGetStatus%(1);
  else
    ' do nothing (for now at least)
  endif;
  return 1;
end;

proc fireTMSWithPause()
  var curTime;
  View(data%);
  curTime:=Maxtime();

  if ((curTime >= nextTMSFireTime)) then
    fireTMS%();
    lastTMSFireTime:=curTime;
    nextTMSFireTime:=curTime+getInterStimulusInterval();
  endif;
end;

func armTMS%()

  if (TMSwhichMagstim% = TMSMAGSTIM200%) then
    TMSSetRemoteControl%(1);
    TMSArmTMS%(1);
  else
  '  SampleSeqVar(6, 0x0200);   'binary: 00000010
  '  SampleSeqVar(8,1);
  '  SampleSeqVar(6, 0x03);
  '  SampleSeqVar(8,1);
    endif;
  return 1;
end;

func disarmTMS%()
  if (TMSwhichMagstim% = TMSMAGSTIM200%) then
    ' do nothing (for now)
  else
  '  SampleSeqVar(6, 0x0100);  'binary: 00000001
  '  SampleSeqVar(8,1);
  '  SampleSeqVar(6, 0x03);
  '  SampleSeqVar(8,1);
    endif;
  return 1;
end;

func setTMSIntensity%(intensity%, whichTMS%)
' the whichTMS% variable applied to which TMS module
' in a paired pulse setup NOT which TMS as win the
' distinction of TMS Magstim 200 versus the old
' Magstim module


  if (TMSwhichMagstim% = TMSMAGSTIM200%) then
    TMSSetRemoteControl%(1);
    if (whichTMS% = 1) then
      TMSSetIntensity%(1, intensity%);
    else
      TMSSetIntensityB%(1, intensity%);
    endif;
  else
    ' currently we only have code for the old magstim
    ' module to do single pulse (not paired pulse)
    '  SampleSeqVar(5, (0x80 BOR intensity%)*256);
    '  SampleSeqVar(7, 1);
  endif;
  return 1;
end;

func fireTMS%()
  if (TMSwhichMagstim% = TMSMAGSTIM200%) then
    TMSTriggerTMS%(1);
  else
    ' no code here currently
    ' we'll just paste the code from the old emg record script
  endif;
  return 1;
end;

func setTMSIntensityPortal%()
  curStimOutput%:=Input("Enter new Stimulator Output", curStimOutput%, 0, 100);
  if (TMSwhichMagstim% = TMSMAGSTIM200%) then
    setTMSIntensity%(curStimOutput%, 1);
  else
    ' currently no code here for the old magstim
  endif;
  return 1;
end;

func setTMSBIntensityPortal%()
  curStimOutput%:=Input("Enter new Stimulator Output", curStimOutput%, 0, 100);
  if (TMSwhichMagstim% = TMSMAGSTIM200%) then
    setTMSIntensity%(curStimOutput%, 2);
  else
    ' currently no code here for the old magstim
  endif;
  return 1;
end;

func setISIPortal%()
  ISI := Input("Enter new inter-stimulus interval", isi, 0);
  if (TMSwhichMagstim% = TMSMAGSTIM200%) then
    TMSSetRemoteControl%(1);
    TMSSetIsi%(1, isi);
  else
    ' currently no paired pulse code for the old magstim
  endif;
  return 1;
end;
'**********************************************************
'*********************************************************
'Filtering Funcs
'proc FILTERexpFilterInit()
'  FILTERexpFilterCursorStart% := CursorNew();
'  FILTERexpFilterCursorEnd% := CursorNew();
'  CursorLabel(4, FILTERexpFilterCursorStart%, "filter start");
'  CursorLabel(4, FILTERexpFilterCursorEnd%, "filter end");
'  Cursor(FILTERexpFilterCursorStart%, XToBin(FILTERexpFilterStart));
'  Cursor(FILTERexpFilterCursorEnd%, XToBin(FILTERexpFilterEnd));
'end;

proc FILTERsubtractExp(chan%, sTime, eTime)
  var length%;
  var sBin%, eBin%, i%;
  var coefs[3], err;
  View(resultViewH%);
  sBin% := XToBin(sTime);
  eBin% := XToBin(eTime);
  length% := eBin% - sBin%;
  var xs[length%], ys[length%], fitys[length%];
  ArrConst(ys, View(resultViewH%, chan%).[sBin%:length%]);
  ArrConst(xs, BinSize());
  xs[0] := sTime;
  ArrIntgl(xs);
  FitExp(3, ys, xs);
  FitExp(2, 0, -10000000, 100000000);
  FitExp(0, 1, -10000000, 100000000);
  FitExp(1, .01, 0.0001, 100000000);
  var ret%;
  ret% := FitExp(coefs, err);
  docase
  case (ret% = 1) then
    printlog("ERROR: Exp fit did not converge.\n");
  case (ret% = 0) then
    printlog("SUCCESS: Fit converged.\n");
  case (ret% = -1) then
    printlog("ERROR: fit is not improving but value may be ok.\n");
  case (ret% < -1) then
    printlog("ERROR: unknown error occured during fit.\n");
  endcase;
  for i% := 0 to length%-1 do
    fitys[i%] := coefs[0]*exp(-xs[i%]/coefs[1]) + coefs[2];
  next;
  ArrSub(View(resultViewH%, chan%).[sBin%:length%], fitys);

  'display the fit into the second channel
'  ArrConst(View(resultViewH%, 2).[sBin%:length%], fitys);
end;


func remove60Cycle();
'Example script to remove 60Hz from a waveform
'Arrays big enough to hold all the samples from a sweep
' vh% is view handle of current data view
var a[5000],c[5000];
var vh%,mv%,i%,pi;
var srate:=5000.0; 'sampling rate in Hz
var fm:=60.0; 'mains freq in Hz
var st%,ln%,npts;
var amp,ph,th,re,im;
var amp3,ph3,th3,re3,im3;
var amp5,ph5,th5,re5,im5;
pi:=4.0*atan(1.0);
vh%:=View(); 'current view holding sampled data
ArrConst(a[],View(resultViewH%,1).[]);' copy channel 2 to array a[]
'ChanData(filteredWaveformChan%, a[], currentTrigTime - .1, currentTrigTime + .9);

st%:=1000; 'start point in array for resolver
ln%:=5000-st%; 'length of resolve
npts:=ln%;

'Fourier sum via resolver technique
th:=2.0*pi*fm/srate; 'pre-compute fundamental phase parameter
for i%:=0 to 4999 do
 c[i%]:=sin(th*i%);
next;
im:=2.0*arrdot(a[st%:ln%],c[st%:ln%])/npts; 'imag component
for i%:=0 to 4999 do
 c[i%]:=cos(th*i%);
next;
re:=2.0*arrdot(a[st%:ln%],c[st%:ln%])/npts; 'real component
amp:=sqrt(re*re+im*im); ' amplitude
ph:=atan(re,im); ' phase

'now same for 3rd harmonic
th3:=8.0*atan(1.0)*3.0*fm/srate; 'pre-compute phase parameter
for i%:=0 to 4999 do
 c[i%]:=sin(th3*i%);
next;
im3:=2.0*arrdot(a[st%:ln%],c[st%:ln%])/npts;
for i%:=0 to 4999 do
 c[i%]:=cos(th3*i%);
next;
re3:=2.0*arrdot(a[st%:ln%],c[st%:ln%])/npts;
amp3:=sqrt(re3*re3+im3*im3); ' amplitude
ph3:=atan(re3,im3); ' phase

'now same for 5th harmonic
th5:=8.0*atan(1.0)*5.0*fm/srate; 'pre-compute phase parameter
for i%:=0 to 4999 do
 c[i%]:=sin(th5*i%);
next;
im5:=2.0*arrdot(a[st%:ln%],c[st%:ln%])/npts;
for i%:=0 to 4999 do
 c[i%]:=cos(th5*i%);
next;
re5:=2.0*arrdot(a[st%:ln%],c[st%:ln%])/npts;
amp5:=sqrt(re5*re5+im5*im5); ' amplitude
ph5:=atan(re5,im5); ' phase
'printlog("amp,ph 1,2,3  ",amp,"  ",ph,"  ",amp3,"  ",ph3,"  ",amp5,"  ",ph5);
'compute correction wave
for i%:=0 to 4999 do
 c[i%]:=(amp*sin(ph+th*i%)+amp3*sin(ph3+th3*i%)+amp5*sin(ph5+th5*i%));
next;

'subtract the correction, leaving result in a[]
arrsub(a[],c[]);

'gash code to see the result

ArrConst(View(resultViewH%,1).[],a[]);' copy array a[] into view
view(resultViewH%).Draw();
return 1;
end;

func removeDrift%();
' This function just uses the example high-pass filter in the filter bank
' to remove baseline drift
' might do more at a later stage
'View(resultViewH%).FiltApply(3, 1, 1, -.1, .9);
  ArrFilt(View(resultViewH%).[], highPassFilter[]);
  return 1;
end;


'do a short time fft on the data..i guess, thinking this wont work
func sFFT%()
  var dataInterval[128];
  var i%, stopAt%;
  i%:=0;
  stopAt%:=5000-128-1;
'  printlog(stopAt%);
  repeat
    ArrConst(dataInterval[], View(resultViewH%,1).[i%:128]);
    ArrFFT(dataInterval[], 5);
    'printlog(Max(dataInterval[]));
    'printlog(i%);
    i%+=1;
    View(resultViewH%,2).[i%]:=Max(dataInterval[]);
  until i%>=stopAt%;
  return 1;
end;
'*********************************************************
'*********************************************************
' Magstim 200^2 control functions (these use the serial line control)

' **************************************
' TMS Serial port funcs
const MAXBUFSIZE% := 1024;

var numCommandsSent% := 0;
var TMSSerialPortBuf%[MAXBUFSIZE%];

func TMSSendCharString%(port%, mes$)
  return SerialWrite(TMSMAGSTIM200SPORT%, mes$);
end;

func TMSSendOneByteCmd%(port%, command%,commanddata%)
  var ret%;
  var portdata%[3];

  numCommandsSent% := numCommandsSent% + 1;
  portdata%[0] := command%;
  portdata%[1] :=commanddata%;
  portdata%[2] := GetCRC%(portdata%[], 2);
  ret% :=  SerialWrite(TMSMAGSTIM200SPORT%, portdata%[]);

  ' we're going to update when we send the TMS machine commands so we can keep sending
  ' it something at least every 0.5 seconds.  SampleStatus returns the status of our sampling
  ' with a return value of 2 meaning that it is in the process of sampling
  'if (data% > -1 and SampleStatus() = 2) then
    TMSlastCommandTime := View(0).Maxtime();
  'endif;

if (ret% > 0) then
    'return TMSCheckCommand%(port%, command%);
    return 0;
  else
    return ret%;
  endif;
end;

func GetCRC%(data%[], numchars%)
  var i%;
  var sum%;
  sum% := 0;
  for i%:=0 to (numchars%-1) do
    sum% += data%[i%];
  next;
  if (sum% > 0xff) then
    sum% := sum% band 0xff;
  endif;
  sum% := BitWiseComplement%(sum%);
  return sum%;
end;

' cuz Spike is effin retarded, we've got to write our own
func BitWiseComplement%(num%)
  var newnum%;
  newnum% := 0;
  if (not(num% band 0x01)) then
    newnum% += 0x01;
  endif;
  if (not(num% band 0x02)) then
    newnum% += 0x02;
  endif;
  if (not(num% band 0x04)) then
    newnum% += 0x04;
  endif;
  if (not(num% band 0x08)) then
    newnum% += 0x08;
  endif;
  if (not(num% band 0x10)) then
    newnum% += 0x10;
  endif;
  if (not(num% band 0x20)) then
    newnum% += 0x20;
  endif;
  if (not(num% band 0x40)) then
    newnum% += 0x40;
  endif;
  if (not(num% band 0x80)) then
    newnum% += 0x80;
  endif;
  return newnum%;
end;

func TMSOpenConnection%(port%)

  var ret%;
  if (TMSwhichMagstim% = TMSMAGSTIM200%) then
    ret% := SerialOpen(TMSMAGSTIM200SPORT%, 9600, 8, 0, 1, 0); '9600 is the bit rate
    if (ret% < 0) then
      printlog("Error occured in opening serial connection: %d\n", ret%);
      return ret%;
    endif;
  else
    ' do nothing for the old magstim
  endif;
  return 0;
end;

func TMSFlushRecvBuffer%(port%)
  var buf%[1024];
'  while (SerialCount(port%) > 0) do
'    SerialRead(port%, buf%[]);
'  wend;
  if (SerialCount(TMSMAGSTIM200SPORT%) > 0) then
    SerialRead(TMSMAGSTIM200SPORT%, buf%[]);
  endif;
  return 0;
end;

func TMSGetStatus%(port%)
  var statusbyte%;
  TMSFlushRecvBuffer%(port%);
  if (TMSSendOneByteCmd%(TMSMAGSTIM200SPORT%, 0x4A, 0x40) < 0) then
    return -1;
  endif;
  TMSCheckCommand%(TMSMAGSTIM200SPORT%, 0x4A);
'  printlog("Num chars read: %d\n", SerialRead(port%, statusstr$));
'  SerialRead(port%, statusstr%[]);
'  printlog("status: %s\n", statusstr$);
'  if (statusstr%[0] = 0x4A) then
'    printlog("Status command acknowledged\n");
'  else
'    printlog("Error: status command not acknowledged");
'    return -2;
'  endif;

  statusbyte% := TMSSerialPortBuf%[1];
  docase
    case (statusbyte% band 0x01) then
      printlog("Status: standby\n");
    case (statusbyte% band 0x02) then
      printlog("Status: armed\n");
    case (statusbyte% band 0x04) then
      printlog("Status: ready\n");
    else
      printlog("Status: unknown\n");
  endcase;

  if (statusbyte% band 0x80) then
    printlog("Coil: present\n");
  else
    if (statusbyte% band 0x10) then
      printlog("Coil: replace\n");
    endif;
  endif;

  if (statusbyte% band 0x20) then
    if (statusbyte% band 0x40) then
      printlog("Error: fatal\n");
    else
      printlog("Error: non-fatal\n");
    endif;
  else
    printlog("Error: none\n");
  endif;

  if (statusbyte% band 0x80) then
    printlog("Remote control: on\n");
  else
    printlog("Remote control: off\n");
  endif;
  printlog("Power A: %s\n", Chr$(TMSSerialPortBuf%[2]) + Chr$(TMSSerialPortBuf%[3]) + Chr$(TMSSerialPortBuf%[4]));
  printlog("Power B: %s\n", Chr$(TMSSerialPortBuf%[5]) + Chr$(TMSSerialPortBuf%[6]) + Chr$(TMSSerialPortBuf%[7]));
  printlog("ISI: %s\n", Chr$(TMSSerialPortBuf%[8]) + Chr$(TMSSerialPortBuf%[9]) + Chr$(TMSSerialPortBuf%[10]));
  return 0;
end;

func TMSCheckCommand%(port%, cmd%)
  while (SerialCount(TMSMAGSTIM200SPORT%) < 3) do
    Yield();
  wend;
  if (SerialCount(TMSMAGSTIM200SPORT%) > 0) then
    SerialRead(TMSMAGSTIM200SPORT%, TMSSerialPortBuf%[]);
    if (TMSSerialPortBuf%[0] = Asc("?")) then
      printlog("Error: command not understood\n");
      return -1;
    endif;
    if (TMSSerialPortBuf%[0] = cmd%) then
      printlog("Command acknowledged\n");
    else
      printlog("Command not acknowledged\n");
      return -1;
    endif;
    docase
    case (TMSSerialPortBuf%[1] = Asc("?")) then
      printlog("Error: command data incorrect\n");
      return -1;
    case (TMSSerialPortBuf%[1] = Asc("S")) then
      printlog("Error: command not valid for current status\n");
      return -1;
    else
      printlog("Command completed\n");
      return 0;
    endcase;
  endif;
end;

func TMSSetRemoteControl%(port%)
TMSSendOneByteCmd%(port%, 0x51, 0x40);
TMSSendOneByteCmd%(port%, 0x45, 0x42);
  if (TMSSendOneByteCmd%(TMSMAGSTIM200SPORT%, 0x51, 0x40) < 0) then
    'printlog("Error: could not activate remote control of TMS\n");
    return -1;
  endif;
  return 0;
end;

func TMSSendThreeByteCmd%(port%, cmd%, data$)
  var portdata%[5];
  portdata%[0] := cmd%;
  portdata%[1] := Asc(Mid$(data$,1,1));
  portdata%[2] := Asc(Mid$(data$,2,1));
  portdata%[3] := Asc(Mid$(data$,3,1));
  portdata%[4] := GetCRC%(portdata%[], 4);
  return SerialWrite(TMSMAGSTIM200SPORT%, portdata%[]);
end;

func TMSSetIntensity%(port%, power%)
  if (power% < 0) then
    return -1;
  endif;
  var portdata%;
  var powerstring$;
  powerstring$ := Print$("%03d", power%);
  printlog("Setting TMS intensity: " + powerstring$ + "\n");
  return TMSSendThreeByteCmd%(TMSMAGSTIM200SPORT%, 0x40, powerstring$);
end;

func TMSSetIntensityB%(port%, power%)
  if (power% < 0) then
    return -1;
  endif;
  var portdata%;
  var powerstring$;
  powerstring$ := Print$("%03d", power%);
  printlog("Setting TMS intensity: " + powerstring$ + "\n");
  return TMSSendThreeByteCmd%(TMSMAGSTIM200SPORT%, 0x41, powerstring$);
end;

func TMSSetISI%(port%, isi%)
  if (isi% < 0) then
    return -1;
  endif;
  var timestring$;
  timestring$ := Print$("%03d", isi%);
  printlog("Setting inter-stimulus interval: " + timestring$ + "\n");
  TMSFlushRecvBuffer%(1);
  TMSSendThreeByteCmd%(port%, 0x43, timestring$);
  TMSCheckCommand%(port%, 0x43);
end;

func TMSArmTMS%(port%)
  TMSFlushRecvBuffer%(port%);
    printlog("Arming TMS\n");
    'TMSSendOneByteCmd%(port%, 0x56, 0x40);
    TMSSendOneByteCmd%(port%, 0x45, 0x42);
    'TMSTriggerTMS%(port%);
'TMSCheckCommand%(port%, 0x45);
end;

func TMSTriggerTMS%(port%)
  printlog("Triggering TMS\n");
'TMSSendOneByteCmd%(port%, 0x51, 0x40);
'TMSSendOneByteCmd%(port%, 0x56, 0x40); 'sending it via serial line
'TMSSendOneByteCmd%(port%, 0x64, 0x40);
TMSSendOneByteCmd%(port%, 0x45, 0x48); 'sending it via serial line
'TMSSendOneByteCmd%(port%, 0x45, 0x4A); 'sending it via serial line
'  SampleSeqVar(10, 1); 'for sending it via pulse sequence file
  'return 0;
end;

func TMSCloseConnection%(port%)
  if (TMSwhichMagstim% = TMSMAGSTIM200%) then
    SerialClose(TMSMAGSTIM200SPORT%);
    printlog("Number of commands sent: %d\n", numCommandsSent%);
  else
    ' do nothing for the old magstim
  endif;
  return 0;
end;

func TMSResetRemoteControl%(port%)
  return TMSSendOneByteCmd%(port%, 0x52, 0x40);
end;
'--------------------------------------------------'
'Saving of all cortical VA protocols'
'--------------------------------------------------'
func Finish%()
    SampleStop();                                     'stop sampling'

    var fName$, fd%;
    	fName$ := View(cVAdata%).FileName$(3);
    	fd% := FileNew(1);
    	if (fd% < 0) then
    		printlog("Could not open text file to save data, printing to log window.\n");
    	endif;
    	'if (fd% < 0) then
    	'	printlog("%sSTIM\t%sVAL\n", fName$, fName$);
    	'else
    	'	View(fd%).print("%sSTIM\t%sVAL\n", fName$, fName$); 'Do I need this?'
    	'endif;
    	var i%;
    	for i% := 0 to 5 do
    			View(fd%).print("%d\t%f\n", i%, NormedMEPArr[i%]);
          View(fd%).print("%d\t%f\n", i%, MEPTimeArr[i%]);
    		next;
    	var ret%;
    	if (fd% >= 0) then

      docase
'--------------------------------------------------'
'File naming for arm posture protocols'
'--------------------------------------------------'
      case cVAprotocol$ = "Arm Posture" then
        docase
          case SubProtocol$ = "45deg" then
          docase
            case PercentMVC$ = "cVAtestZero" then
              View(cVAdata%).FileSaveAs(print$("%s%s", fName$, "_cVA_Arm45_00p"), -1);
              ret% := View(fd%).FileSaveAs(print$("%s%s", fName$, "_cVA_Arm45_00p.txt"), 1, 0, "Save analysis as...");
            case PercentMVC$ = "cVAtestFifty" then
              View(cVAdata%).FileSaveAs(print$("%s%s", fName$, "_cVA_Arm45_50p"), -1);
              ret% := View(fd%).FileSaveAs(print$("%s%s", fName$, "_cVA_Arm45_50p.txt"), 1, 0, "Save analysis as...");
            case PercentMVC$ = "cVAtestSeventy" then
              View(cVAdata%).FileSaveAs(print$("%s%s", fName$, "_cVA_Arm45_75p"), -1);
              ret% := View(fd%).FileSaveAs(print$("%s%s", fName$, "_cVA_Arm45_75p.txt"), 1, 0, "Save analysis as...");
            case PercentMVC$ = "cVAtestOnehundred" then
              View(cVAdata%).FileSaveAs(print$("%s%s", fName$, "_cVA_Arm45_100p"), -1);
              ret% := View(fd%).FileSaveAs(print$("%s%s", fName$, "_cVA_Arm45_100p.txt"), 1, 0, "Save analysis as...");
          endcase;
          case SubProtocol$ = "90deg" then
          docase
            case PercentMVC$ = "cVAtestZero" then
              View(cVAdata%).FileSaveAs(print$("%s%s", fName$, "_cVA_Arm90_00p"), -1);
              ret% := View(fd%).FileSaveAs(print$("%s%s", fName$, "_cVA_Arm90_00p.txt"), 1, 0, "Save analysis as...");
            case PercentMVC$ = "cVAtestFifty" then
              View(cVAdata%).FileSaveAs(print$("%s%s", fName$, "_cVA_Arm90_50p"), -1);
              ret% := View(fd%).FileSaveAs(print$("%s%s", fName$, "_cVA_Arm90_50p.txt"), 1, 0, "Save analysis as...");
            case PercentMVC$ = "cVAtestSeventy" then
              View(cVAdata%).FileSaveAs(print$("%s%s", fName$, "_cVA_Arm90_75p"), -1);
              ret% := View(fd%).FileSaveAs(print$("%s%s", fName$, "_cVA_Arm90_75p.txt"), 1, 0, "Save analysis as...");
            case PercentMVC$ = "cVAtestOnehundred" then
              View(cVAdata%).FileSaveAs(print$("%s%s", fName$, "_cVA_Arm90_100p"), -1);
              ret% := View(fd%).FileSaveAs(print$("%s%s", fName$, "_cVA_Arm90_100p.txt"), 1, 0, "Save analysis as...");
          endcase;
          case SubProtocol$ = "135deg" then
          docase
            case PercentMVC$ = "cVAtestZero" then
              View(cVAdata%).FileSaveAs(print$("%s%s", fName$, "_cVA_Arm135_00p"), -1);
              ret% := View(fd%).FileSaveAs(print$("%s%s", fName$, "_cVA_Arm135_00p.txt"), 1, 0, "Save analysis as...");
            case PercentMVC$ = "cVAtestFifty" then
              View(cVAdata%).FileSaveAs(print$("%s%s", fName$, "_cVA_Arm135_50p"), -1);
              ret% := View(fd%).FileSaveAs(print$("%s%s", fName$, "_cVA_Arm135_50p.txt"), 1, 0, "Save analysis as...");
            case PercentMVC$ = "cVAtestSeventy" then
              View(cVAdata%).FileSaveAs(print$("%s%s", fName$, "_cVA_Arm135_75p"), -1);
              ret% := View(fd%).FileSaveAs(print$("%s%s", fName$, "_cVA_Arm135_75p.txt"), 1, 0, "Save analysis as...");
            case PercentMVC$ = "cVAtestOnehundred" then
              View(cVAdata%).FileSaveAs(print$("%s%s", fName$, "_cVA_Arm135_100p"), -1);
              ret% := View(fd%).FileSaveAs(print$("%s%s", fName$, "_cVA_Arm135_100p.txt"), 1, 0, "Save analysis as...");
          endcase;
'--------------------------------------------------'
'File naming for painful cutaneous reflex protocols'
'--------------------------------------------------'
      case cVAprotocol$ = "Cutaneous Reflex" then
        docase
          case SubProtocol$ = "40ms Cutaneous Reflex" then
          docase
            case PercentMVC$ = "cVAtestZero" then
              View(cVAdata%).FileSaveAs(print$("%s%s", fName$, "_cVA_CR40_00p"), -1);
              ret% := View(fd%).FileSaveAs(print$("%s%s", fName$, "_cVA_CR40_00p.txt"), 1, 0, "Save analysis as...");
            case PercentMVC$ = "cVAtestFifty" then
              View(cVAdata%).FileSaveAs(print$("%s%s", fName$, "_cVA_CR40_50p"), -1);
              ret% := View(fd%).FileSaveAs(print$("%s%s", fName$, "_cVA_CR40_50p.txt"), 1, 0, "Save analysis as...");
            case PercentMVC$ = "cVAtestSeventy" then
              View(cVAdata%).FileSaveAs(print$("%s%s", fName$, "_cVA_CR40_75p"), -1);
              ret% := View(fd%).FileSaveAs(print$("%s%s", fName$, "_cVA_CR40_75p.txt"), 1, 0, "Save analysis as...");
            case PercentMVC$ = "cVAtestOnehundred" then
              View(cVAdata%).FileSaveAs(print$("%s%s", fName$, "_cVA_CR40_100p"), -1);
              ret% := View(fd%).FileSaveAs(print$("%s%s", fName$, "_cVA_CR40_100p.txt"), 1, 0, "Save analysis as...");
          endcase;
          case SubProtocol$ = "70ms Cutaneous Reflex" then
          docase
            case PercentMVC$ = "cVAtestZero" then
              View(cVAdata%).FileSaveAs(print$("%s%s", fName$, "_cVA_CR70_00p"), -1);
              ret% := View(fd%).FileSaveAs(print$("%s%s", fName$, "_cVA_CR70_00p.txt"), 1, 0, "Save analysis as...");
            case PercentMVC$ = "cVAtestFifty" then
              View(cVAdata%).FileSaveAs(print$("%s%s", fName$, "_cVA_CR70_50p"), -1);
              ret% := View(fd%).FileSaveAs(print$("%s%s", fName$, "_cVA_CR70_50p.txt"), 1, 0, "Save analysis as...");
            case PercentMVC$ = "cVAtestSeventy" then
              View(cVAdata%).FileSaveAs(print$("%s%s", fName$, "_cVA_CR70_75p"), -1);
              ret% := View(fd%).FileSaveAs(print$("%s%s", fName$, "_cVA_CR70_75p.txt"), 1, 0, "Save analysis as...");
            case PercentMVC$ = "cVAtestOnehundred" then
              View(cVAdata%).FileSaveAs(print$("%s%s", fName$, "_cVA_CR70_100p"), -1);
              ret% := View(fd%).FileSaveAs(print$("%s%s", fName$, "_cVA_CR70_100p.txt"), 1, 0, "Save analysis as...");
          endcase;
          case SubProtocol$ = "100ms Cutaneous Reflex" then
          docase
            case PercentMVC$ = "cVAtestZero" then
              View(cVAdata%).FileSaveAs(print$("%s%s", fName$, "_cVA_CR100_00p"), -1);
              ret% := View(fd%).FileSaveAs(print$("%s%s", fName$, "_cVA_CR100_00p.txt"), 1, 0, "Save analysis as...");
            case PercentMVC$ = "cVAtestFifty" then
              View(cVAdata%).FileSaveAs(print$("%s%s", fName$, "_cVA_CR100_50p"), -1);
              ret% := View(fd%).FileSaveAs(print$("%s%s", fName$, "_cVA_CR100_50p.txt"), 1, 0, "Save analysis as...");
            case PercentMVC$ = "cVAtestSeventy" then
              View(cVAdata%).FileSaveAs(print$("%s%s", fName$, "_cVA_CR100_75p"), -1);
              ret% := View(fd%).FileSaveAs(print$("%s%s", fName$, "_cVA_CR100_75p.txt"), 1, 0, "Save analysis as...");
            case PercentMVC$ = "cVAtestOnehundred" then
              View(cVAdata%).FileSaveAs(print$("%s%s", fName$, "_cVA_CR100_100p"), -1);
              ret% := View(fd%).FileSaveAs(print$("%s%s", fName$, "_cVA_CR100_100p.txt"), 1, 0, "Save analysis as...");
          endcase;
'--------------------------------------------------'
'File naming for paired pulse protocols'
'--------------------------------------------------'
      case cVAprotocol$ = "Paired Pulse" then
        docase
          case SubProtocol$ = "1.5ms PP" then
          docase
            case PercentMVC$ = "cVAtestZero" then
              View(cVAdata%).FileSaveAs(print$("%s%s", fName$, "_cVA_PP1o5_00p"), -1);
              ret% := View(fd%).FileSaveAs(print$("%s%s", fName$, "_cVA_PP1o5_00p.txt"), 1, 0, "Save analysis as...");
            case PercentMVC$ = "cVAtestFifty" then
              View(cVAdata%).FileSaveAs(print$("%s%s", fName$, "_cVA_PP1o5_50p"), -1);
              ret% := View(fd%).FileSaveAs(print$("%s%s", fName$, "_cVA_PP1o5_50p.txt"), 1, 0, "Save analysis as...");
            case PercentMVC$ = "cVAtestSeventy" then
              View(cVAdata%).FileSaveAs(print$("%s%s", fName$, "_cVA_PP1o5_75p"), -1);
              ret% := View(fd%).FileSaveAs(print$("%s%s", fName$, "_cVA_PP1o5_75p.txt"), 1, 0, "Save analysis as...");
            case PercentMVC$ = "cVAtestOnehundred" then
              View(cVAdata%).FileSaveAs(print$("%s%s", fName$, "_cVA_PP1o5_100p"), -1);
              ret% := View(fd%).FileSaveAs(print$("%s%s", fName$, "_cVA_PP1o5_100p.txt"), 1, 0, "Save analysis as...");
          endcase;
          case SubProtocol$ = "10ms PP" then
          docase
            case PercentMVC$ = "cVAtestZero" then
              View(cVAdata%).FileSaveAs(print$("%s%s", fName$, "_cVA_PP10_00p"), -1);
              ret% := View(fd%).FileSaveAs(print$("%s%s", fName$, "_cVA_PP10_00p.txt"), 1, 0, "Save analysis as...");
            case PercentMVC$ = "cVAtestFifty" then
              View(cVAdata%).FileSaveAs(print$("%s%s", fName$, "_cVA_PP10_50p"), -1);
              ret% := View(fd%).FileSaveAs(print$("%s%s", fName$, "_cVA_PP10_50p.txt"), 1, 0, "Save analysis as...");
            case PercentMVC$ = "cVAtestSeventy" then
              View(cVAdata%).FileSaveAs(print$("%s%s", fName$, "_cVA_PP10_75p"), -1);
              ret% := View(fd%).FileSaveAs(print$("%s%s", fName$, "_cVA_PP10_75p.txt"), 1, 0, "Save analysis as...");
            case PercentMVC$ = "cVAtestOnehundred" then
              View(cVAdata%).FileSaveAs(print$("%s%s", fName$, "_cVA_PP10_100p"), -1);
              ret% := View(fd%).FileSaveAs(print$("%s%s", fName$, "_cVA_PP10_100p.txt"), 1, 0, "Save analysis as...");
          endcase;
          case SubProtocol$ = "30ms PP" then
          docase
            case PercentMVC$ = "cVAtestZero" then
              View(cVAdata%).FileSaveAs(print$("%s%s", fName$, "_cVA_PP30_00p"), -1);
              ret% := View(fd%).FileSaveAs(print$("%s%s", fName$, "_cVA_PP30_00p.txt"), 1, 0, "Save analysis as...");
            case PercentMVC$ = "cVAtestFifty" then
              View(cVAdata%).FileSaveAs(print$("%s%s", fName$, "_cVA_PP30_50p"), -1);
              ret% := View(fd%).FileSaveAs(print$("%s%s", fName$, "_cVA_PP30_50p.txt"), 1, 0, "Save analysis as...");
            case PercentMVC$ = "cVAtestSeventy" then
              View(cVAdata%).FileSaveAs(print$("%s%s", fName$, "_cVA_PP30_75p"), -1);
              ret% := View(fd%).FileSaveAs(print$("%s%s", fName$, "_cVA_PP30_75p.txt"), 1, 0, "Save analysis as...");
            case PercentMVC$ = "cVAtestOnehundred" then
              View(cVAdata%).FileSaveAs(print$("%s%s", fName$, "_cVA_PP30_100p"), -1);
              ret% := View(fd%).FileSaveAs(print$("%s%s", fName$, "_cVA_PP30_100p.txt"), 1, 0, "Save analysis as...");
          endcase;
                endcase;
            endcase
        endcase
    endcase
endif
    		if (ret% < 0) then
    			View(fd%);
    			FileClose(0, -1);
    		else
    			View(fd%);
    			FileClose();
    		endif;
    View(cVAdata%);
    FileClose(0,-1);
    cVAdata%:=-1;
                waitforTMS%:= 0;
end;
