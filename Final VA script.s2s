'Debug("");

'----------------------------------------------------------------------------------------------------------------------
' Global Variables
'----------------------------------------------------------------------------------------------------------------------

'-------General set-up/status variables-----------------------------------------------------
var Protocol$:="Stopped";
var TMSstatus$:= "Not Armed";
var cVA$:="Arm Posture";
var ready$:="Yes";
var Muscle$, Sensor%;
var subjectID$;
const allow%:=1023; 'supposed to allow the most functionality during idle (see Toolbar() help... "The number is the sum of possible activity codes"

const MagstimSerialPort% := 3; '******* Important variable for troubleshooting code on new computers! ****************************************'   
'********* If the code does not appear to run at all, you likely do not have the Magstim connected to the correct serial (COM) port. *********'
'********* If using serial to USB, it must be plugged into the correct USB port. *************************************************************'
'********* Check Device Manager to find out which COM port is being used. ********************************************************************'
'*********************************************************************************************************************************************'

'SampleKey() control and marking of Digitimer/Magstim firing
var t$:="t"; var d$:="d"; var a$:="a"; 'Digitimer specific: "t" and "d" are individual pulses, "a" is 10 pulse train
var u$:="u"; var i$:="i"; var o$:="o"; var p$:="p"; 'TMS specific not used anymore
var s$:="s"; 'Fires single TMS pulse during  

'Channel variables
var curChan%:=1; var BicepEMGchan%:= 1; const TrigEventChan%:= 6;
var cScale, cOffset;

'Data/results set-up
var MwaveThreshdata%:= -1; var findrMTdata%:=-1; var mMaxData%:=-1;
var MVCdata%:=-1; var cVAData%:=-1; var pVAdata%:=-1;
var MwaveBarGraph%:=-1; var ForceFeedbackBarGraph%:=-1; var rMTBarGraph%:=-1; var rcBarGraph%:=-1;
var data%:=-1; var resultViewH%; 
'-------------------------------------------------------------------------------------------


'-------Idle related variables--------------------------------------------------------------

'Force feedback
var EMGlvl, ForceFeedbackLevel;

'TMS and Digitimer control 
var Trial%:=0; var stimcount%:=0;
var sTime := 0; var currentTrigTime:=-1;
var eTime, rTime, waitforTMStoArm, waitTime, curTime, ReadyTime; 
var TMSlastCommandTime; 'Important for ensuring constant communication between Magstim and Spike2
var MVCstartTime[6]; var MVCendTime[6];
var updateNecessary%:=0; var newestEvent;
var WaitLoop%:= 1; var TimeOne,TimeTwo; 'Ensures Magstim has time to charge during "At Rest" cVA stimulations
'-------------------------------------------------------------------------------------------


'-------Analysis related variables-----------------------------------------------------------

'Find M-wave/MP max
var avgPPdiff; var PPArr[500]; var PPdiff[500]; var PercentDiff[500]; var PDC%;
var prevPeakToPeak:= -2; var curPeakToPeak:=0;
var counter%:=0; 
var skip%:= 0; 'For skipping dlg box prompt during MP stimulation
'pVA variables
var MVCtwitchAmp,MVCtwitchPP,getTwitch%,TwitchTrial%,RestingTwitchIndex%,RestingTwitch,RestingTwitchPP;
var MVCtwitchArr[10]; var RestingTwitchArr[10]; var VA_Arr[10];
'-------------------------------------------------------------------------------------------


'-------MVC related variables---------------------------------------------------------------

'MVC arrays (might be able to make these local)
var AvgBicep[5500]; var BicepRMS[5500]; 
var FxArray[5500]; var FyArray[5500]; var FzArray[5500];
var MxArray[5500]; var MyArray[5500]; var MzArray[5500];
'Individual MVC trial arrays (must be global, but I think should be [3][1])
var TrialBicepMVC[6][1]; var avgFMarray[1][6];
var TrialFxMVC[6][1]; var TrialFyMVC[6][1]; var TrialFzMVC[6][1];
var TrialMxMVC[6][1]; var TrialMyMVC[6][1]; var TrialMzMVC[6][1];
var avgFxMVC, avgFyMVC, avgFzMVC;
var avgMxMVC, avgMyMVC, avgMzMVC;
'Variables for active cursor method of MVC detection
var activeMVC_one, activeMVC_two, activeMVC_three, activeFxAvg;

'Basis for control of effort levels during pVA and cVA
var avgBicepMVC:=5.5;  
var UpperEMGLimit, LowerEMGLimit;
var MVClevel$;
'--------------------------------------------------------------------------------------------


'-------Recruitment Curve variables----------------------------------------------------------
var rMT%:= 0;
var RCintensityA%,RCintensityB%,RCintensityC%,RCintensityD%,RCintensityE%,RCintensityF%,RCintensityG%,RCintensityH%,RCintensityI%;
var intA%,intB%,intC%,intD%,intE%,intF%,intG%,intH%,intI%,place%,nextStim%;
var countA%,countB%,countC%,countD%,countE%,countF%,countG%,countH%,countI%;
var RCstimTime,RCstimCount%;
var RCIarray%[55]; var rcPeakToPeak[9][6]; var RCintensity%[9];
'--------------------------------------------------------------------------------------------


'-------Randomization and cVA set-up---------------------------------------------------------
var rNum%:=2;
var numZero%,numTwo%,numThree%,numFour%,numFive%;
var numSix%,numSeven%,numEight%,numNine%,numTen%;
var numEleven%,numTwelve%,numThirteen%,numFourteen%,numFifteen%,numSixteen%;
'--------------------------------------------------------------------------------------------


'-------Non-idle TMS/Magstim specific variables ---------------------------------------------

'Variables left over from MUSC script
var jitter,interStimulusIntervalMin,nextTMSFireTime,lastTMSFireTime,curStimOutput%,ISI; 
var highPassFilter[511];

var TMSintensityA;'changes intensity of first pulse
var TMSpulse$;'changes ISI for cutaneous stim cVA

'--------------------------------------------------------------------------------------------


'----------------------------------'
'Variables not currently being used
'var curHreflex; 
'var PreviousStim$;
var DigitimerPulse$; 'technically still being used, but I think it can be removed
'----------------------------------'


'--------------------------------------------------------------------------------------------
'-------MUSC specific variables (working on getting rid of these)----------------------------


'Filtering
var FILTERexpFilterCursorStart%;
var FILTERexpFilterCursorEnd%;

'analysis variables
const maxIntensities% := 101;
const maxTrials% := 100;
var numPerIntensity%[maxIntensities%];
var valsPerIntensity[maxIntensities%][maxTrials%];
const FITDATAAVG% := 0;
const FITDATAMEDIAN% := 1;
const FITDATAALL% := 2;
var FITuseData% := FITDATAMEDIAN%;
'--------------------------------------------------------------------------------------------
'----------End of Global Variables-----------------------------------------------------------------------------------------------------

'Begining of code functionality
if (TMSOpenConnection%(MagstimSerialPort%) < 0) then
  printlog("Error opening connection to Magstim\n");
  Halt;
endif;


INITIALIZESubjectData();
proc INITIALIZESubjectData()
subjectID$ := Input$("Enter subject ID", "");
'FilePathSet("", 0);
'SampleAutoFile(1);
end;
InitializeSensorInfo();
proc InitializeSensorInfo()
var ok%,Sensor%;
  DlgCreate("Which Force Sensor is attached?");
  DlgList(1,"Sensor","Non-Impaired|SCI"); 
  DlgButton(0,"Cancel");
  DlgButton(1,"OK");
  ok% := DlgShow(Sensor%);
end
'----------------------------------------------------------------------------------------------------------------------
' Set up the Toolbar
'----------------------------------------------------------------------------------------------------------------------

var ButtonDisable%:=0;              ' Global var to hold the value of the toobar buttons which are disabled
var toolText$;                      ' Holds the text string to appear in the toolbar

cVAToolbar();                       'Calls toolbar
Halt;

proc cVAToolbarButtons()               ' Buttons for Toolbar (they're self explanitory for the most part)
ToolbarClear();
ToolbarSet(0,"",Idle%);                  'Call Idle%() whenever there is free time
ToolbarSet(1,"Quit", Back%);
ToolbarSet(10,"Find M-max", FindMwave%);
ToolbarSet(9,"Record M-max", RecMwave%);
ToolbarSet(8,"Find MVC", MVC%);
ToolbarSet(7,"MP Stim", MPstim%);
ToolbarSet(6,"pVA", pVA%);
'ToolbarSet(5,"TMS Locator", TMSToolbar%);
'ToolbarSet(3,"Record rMT", LocateMT%);
ToolbarSet(4, "RC", actualRC%);'RCtoolbar%);
ToolbarSet(3,"cVA", cVA%);
ToolbarSet(-2,"Stop Sampling", HaltRec%);
toolText$:="Voluntary Activation Protocol";          ' Sets the text to appear on the left in the toolbar
ToolbarText(toolText$);                         ' Puts the toolText into the toolbar (in case we are returning to this toolbar)


if ButtonDisable% = 0 then         ' Default setting on startup (everything enabled except "Stop Sampling")
  ToolbarEnable(7, 1);
  ToolbarEnable(6, 1);
  ToolbarEnable(5, 1);
  ToolbarEnable(4, 1);
  ToolbarEnable(3, 1);
  ToolbarEnable(2, 1);
  ToolbarEnable(1, 1);
endif;

if ButtonDisable% = 1 then         ' Disable all tooolbar buttons when sampling (except "Stop Sampling")
  ToolbarEnable(7, 0);
  ToolbarEnable(6, 0);
  ToolbarEnable(5, 0);
  ToolbarEnable(4, 0);
  ToolbarEnable(3, 0);
  ToolbarEnable(2, 1);
  ToolbarEnable(1, 0);
endif;
end;
func cVAToolbar()
cVAToolbarButtons();                ' Set up main toolbar buttons
Toolbar(toolText$, allow%);         ' Displays and waits at toolbar
return 1;
end;
func TMStoolbar%()                ' Do the pVA toolbar
TMStoolbarButtons();              ' Set up pVA toolbar buttons
var pVAButtonDisable%:= 0;                      ' Default toolbar button status
Toolbar(toolText$, allow%);            ' Displays and waits at toolbar
cVAToolbarButtons();              ' When we leave, set up buttons for main toolbar again
return 1;                    ' Stay in main toolbar
end;
proc TMSToolbarButtons()            ' Buttons for pVA Toolbar
ToolbarClear();
ToolbarSet(0,"",Idle%);                  ' Call Idle%() whenever there is free time
ToolbarSet(1,"Back", Back%);
ToolbarSet(4,"Start", LocateMT%);
ToolbarSet(3,"Fire TMS", Fire%);
ToolbarSet(-2,"Halt Rec", HaltRec%);
toolText$:="Locate Motor Threshold";              ' Sets the text to appear on the left in the toolbar
ToolbarText(toolText$);                         ' Puts the toolText into the toolbar (in case we are returning to this toolbar)

end;
func Fire%()
SampleKey(a$);
TMSTriggerTMS%(1);
end;
'----------------------------------------------------------------------------------------------------------------------
' Sampling function for finding M-wave max (M-max)
'----------------------------------------------------------------------------------------------------------------------
func FindMwave%()
Protocol$:= "find m-wave";
if skip% = 0 then 
    var ok%,which%;
    DlgCreate("Which Muscle Group?");
    DlgList(1,"Muscle Group","Biceps|Triceps"); 'version 3 onwards
    DlgButton(0,"Cancel");
    DlgButton(1,"OK");
    ok% := DlgShow(which%);
    if which% = 0 then
        Muscle$ := "Biceps";
    endif;
    if which% = 1 then
        Muscle$ := "Triceps";
    endif;
else
    Muscle$:= "MP Stim";
endif;

View(LogHandle());            'Make log view the current view
Window(0,80,100,100);         'Display it at the bottom of the screen
WindowVisible(1);             'Make it visible

'if (MwaveThreshdata%>0) then                      ' If there is already a data view open...
'  View(MwaveThreshdata%);                       ' ...close it
'  FileClose(0, -1);                             ' No point setting data% to 0...
'endif;

MwaveThreshdata%:=FileNew(0,0);                 ' Open a new data file for sampling
if MwaveThreshdata%<0 then
    SampleStop();
  FileClose(-1,-1);
  MwaveThreshdata%:=FileNew(0,0);
    if MwaveThreshdata%<0 then
        Message("Unable to open new data file");Halt;
    endif;
endif;

cScale := ChanScale(curChan%);
cOffset := ChanOffset(curChan%);
View(MwaveThreshdata%).XRange(-1);
View(MwaveThreshdata%).YRange(1,-5000,5000);
View(MwaveThreshdata%).YRange(2,-5000,5000);
View(MwaveThreshdata%).YRange(5,-1,3);
View(MwaveThreshdata%).WindowVisible(1);
View(MwaveThreshdata%).DrawMode(-1,3);              'Set event draw mode to lines (3 for waveform)
View(MwaveThreshdata%).Window(0,0,60,80);            'Make data window right half of screen

'View(MwaveThreshdata%).FiltCalc(3, BinSize(1), highPassFilter[]); 'set the filter
'View(MwaveThreshdata%).ChanProcessAdd(1, 1, 0.01); 'Channel, 1=Smooth, Time constant (s)
'View(MwaveThreshdata%).ChanProcessAdd(1, 9, 0.01); 'Channel, 9=Median filter, Time constant (s)
if Muscle$ = "MP Stim" then 'hide everything but Fz channel
    ChanHide(1);ChanHide(2);ChanHide(3);ChanHide(4);ChanHide(5);ChanHide(7);ChanHide(11);ChanHide(8);ChanHide(9);ChanHide(30);ChanHide(31);ChanHide(32);
else 'hide everything but Biceps and Triceps channels
    ChanHide(3);ChanHide(4);ChanHide(5);ChanHide(7);ChanHide(11);ChanHide(8);ChanHide(9);ChanHide(10);ChanHide(30);ChanHide(31);ChanHide(32);
endif;

ViewTrigger(TrigEventChan%, .05, .25, 1,-1); 'reset the view after each trigger'
resultViewH%:=SetResult(600, BinSize(1), -.1, "Filtered EMG", "s", ChanUnits$(1), "Time", "Bicep EMG");
View(resultViewH%).DrawMode(1, 3);
View(resultViewH%).YRange(1,((-1*cScale)+cOffset),(1*cScale)+cOffset);
View(resultViewH%).WindowVisible(1);
View(resultViewH%).CursorNew(XToBin(0));
View(resultViewH%).Window(0,0,60,80); 'Make EMG results graph window sit between log view and sampling data
Colour(12,6);
'M-wave Peak-to-Peak Bar Graph
'-----------------------------
View(MwaveThreshdata%); ' View sampling data
MwaveBarGraph%:=SetResult(3,1,0,"M-wave Level","");
View(MwaveBarGraph%).XRange(0,3);
docase
case which% = 0 then     
    View(MwaveBarGraph%).YRange(1,0,10000);      'Set Y range to match source waveform channel
case which% = 1 then     
    View(MwaveBarGraph%).YRange(1,0,5000);
case Muscle$ = "MP Stim" then     
    View(MwaveBarGraph%).YRange(1,0,5);
endcase;    
View(MwaveBarGraph%).Window(60,0,100,80); 'Make bar graph window right portion of screen
FrontView(MwaveBarGraph%);
Colour(12,6);
FrontView(LogHandle());              'Bring the Log view to the front
FrontView(MwaveBarGraph%);                  'Bring the bar graph results view to the front
FrontView(MwaveThreshdata%);          'Bring the data view to the front



' here are all the variables we need to re-initialize every time we start a new recording
sTime := 0;
currentTrigTime:=-1;
updateNecessary%:=0;
stimcount% := 0;

SampleStart();                                  ' Start sampling
ButtonDisable% := 1;           'disable buttons
return 1;                    ' and stay in current toolbar
end;

'----------------------------------------------------------------------------------------------------------------------
' M-wave analysis functions
'----------------------------------------------------------------------------------------------------------------------

proc updateData()
if ((Protocol$ = "find m-wave")) then
    if ((Muscle$ = "Biceps")) then
    View(MwaveThreshdata%).ChanData(1, View(resultViewH%,1).[], currentTrigTime-.05, currentTrigTime+.2);
    endif
    if ((Muscle$ = "Triceps")) then
    View(MwaveThreshdata%).ChanData(2, View(resultViewH%,1).[], currentTrigTime-.05, currentTrigTime+.2);
    endif
    if ((Muscle$ = "MP Stim")) then
    View(MwaveThreshdata%).ChanData(5, View(resultViewH%,1).[], currentTrigTime, currentTrigTime+.5);
    endif
endif
if ((Protocol$ = "find rMT")) then
    View(findrMTdata%).ChanData(1, View(resultViewH%,1).[], currentTrigTime-.05, currentTrigTime+.5);
endif
if ((Protocol$ = "Recruitment Curve")) then
    View(data%).ChanData(1, View(resultViewH%,1).[], RCstimTime-.05, RCstimTime+.5);
endif
View(resultViewH%).Draw();
end;

func PeakToPeak(startTime, endTime)
var minVal, maxVal, i%;

View(resultViewH%).Minmax(1, XToBin(startTime), XToBin(endTime), minVal, maxVal);

    printlog("current peak to peak:", maxVal - minVal);
    PPArr[stimcount%]:= maxVal - minVal;
    if(stimcount% = 1) then
      if ((Protocol$ = "find m-wave")) then
        ArrConst(View(MwaveBarGraph%).[:1],PPArr[1]);
      else
        ArrConst(View(rMTBarGraph%).[:1],PPArr[1]);
      endif
      DrawAll();  'update result views
    endif
    if(stimcount% = 2) then
      if ((Protocol$ = "find m-wave")) then
        ArrConst(View(MwaveBarGraph%).[:2],PPArr[1:2]);
      else
        ArrConst(View(rMTBarGraph%).[:2],PPArr[1:2]);
      endif
      DrawAll();  'update result views
    endif
    if(stimcount% > 2) then
      if ((Protocol$ = "find m-wave")) then
        ArrConst(View(MwaveBarGraph%).[:3],PPArr[stimcount%-3:stimcount%]);                      'Set bar graph to new peak to peak value
      endif;
      if ((Protocol$ = "find rMT")) then
        ArrConst(View(rMTBarGraph%).[:3],PPArr[stimcount%-3:stimcount%]);
      endif;
      if ((Protocol$ = "Recruitment Curve")) then
        ArrConst(View(rcBarGraph%).[:3],PPArr[stimcount%-3:stimcount%]);
      endif
      DrawAll();  'update result views
    endif
  return maxVal - minVal;
end;

func DoMwaveAnalyze%();
    var curPeakToPeak;
    view(resultViewH%); 'make sure we are looking at the results view, otherwise we get peak-to-peak of the same sampled data every time
    curPeakToPeak:=PeakToPeak(.001,.5); 'm-wave should be within ~25ms of stim'
    printlog("Current Peak-to-Peak: %d\n", curPeakToPeak);
    'curHreflex:=PeakToPeak(.09,.13); 'H-reflex should be between ~25ms to 50ms of stim'
    'printlog("Current H-reflex Peak-to-Peak: %d\n", curHreflex);
if (stimcount% > 1) then
    PPdiff[stimcount%-2]:= curPeakToPeak - prevPeakToPeak;
    PercentDiff[stimcount%-2]:= (curPeakToPeak - prevPeakToPeak)/prevPeakToPeak*100;
    if PercentDiff[stimcount%-2] < 1 then
        PDC%+=1;
    else
        PDC%:= 0;
'        if PercentDiff[stimcount%-3] < 1 then
'            PDC%:= 1;
'        endif;
    endif;
    
    AnalyzeMwave(curPeakToPeak);
    return 0;
endif
end;

proc AnalyzeMwave(curPeakToPeak)
var MwaveMax, MwaveStimMax, avgPPdiff, MwaveStimIntensity, ret%;
if (stimcount% > 2) then
    avgPPdiff:= (PPdiff[stimcount%-2] + PPdiff[stimcount%-1] + PPdiff[stimcount%])/3;
    if Muscle$ = "MP Stim" then
        avgPPdiff:= avgPPdiff*10; 'if doing MP Stim, PP differences are much smaller, therefor we amplify the difference
    endif;
    if (avgPPdiff > 0.01) then
        'if PDC% < 2 then
        Newsflash("Increase Stimulus Intensity by 10mA",5,0,05,1);
        prevPeakToPeak:=curPeakToPeak;
        ' go back to idle or whatever to continue recording/triggering
    else 'plateau has been reached and we calculate and save final information
        var ok%,continue%; 'but only if user manually reviews data and agrees a plateau has been reached
        DlgCreate("Potential Plateau");
        DlgCheck(1,"Continue?"); 
        DlgButton(0,"Cancel");
        DlgButton(1,"OK");
        ok% := DlgShow(continue%);
        if continue% = 0 then       
            SampleStop();                                   ' Stop sampling
            Protocol$ := "Stopped";
            Newsflash("M-Max Stimulus Intensity Found",10.0,0,05,1);
            var i%, PPvals%;
            PPvals% := FileNew(1);
            for i%:= 0 to len(PPArr[])-1 do;
                View(PPvals%).print("%g",PPArr[i%]);
            next;
            if (PPvals% >= 0) then
                ret% := View(PPvals%).FileSaveAs(print$("%s%s", subjectID$, "_mWave_PeaktoPeaks.txt"), 1, 0, "Save analysis as...");
                if (ret% < 0) then
                    View(PPvals%);
                    FileClose(0, -1);
                else
                    View(PPvals%);
                    FileClose();
                endif;
            endif;
            View(MwaveThreshdata%).FileSaveAs(print$("%s", subjectID$, "_mMax"), -1);
            FileClose(-1,0);
            ButtonDisable%:= 0;
        endif;
    endif;
endif;
end;
'----------------------------------------------------------------------------------------------------------------------
' Record M-max 5 times
'----------------------------------------------------------------------------------------------------------------------
func RecMwave%()
if (mMaxData%>0) then                      ' If there is already a data view open...
  View(mMaxData%);                       ' ...close it
  FileClose(0, -1);                             ' No point setting data% to 0...
endif;

mMaxData%:=FileNew(0,0);                 ' Open a new data file for sampling
if mMaxData%<0 then
    SampleStop();
  FileClose(-1,-1);
  mMaxData%:=FileNew(0,0);
    if mMaxData%<0 then
        Message("Unable to open new data file");Halt;
    endif;
endif;

cScale := ChanScale(curChan%);
cOffset := ChanOffset(curChan%);
View(mMaxData%).XRange(-1);
View(mMaxData%).YRange(1,((-1*cScale)+ cOffset),(1*cScale)+cOffset);
View(mMaxData%).WindowVisible(1);
View(mMaxData%).DrawMode(-1,3);              'Set event draw mode to lines (3 for waveform)
View(mMaxData%).Window(0,0,60,80);            'Make data window right half of screen

ChanHide(3);ChanHide(4);ChanHide(5);ChanHide(8);ChanHide(9);

FrontView(mMaxData%);          'Bring the data view to the front

Trial%:=0; 'Set Trial number to zero before recording starts
var i%;
Protocol$ := "REC m-wave";
SampleStart(); 'begin sampling
  ButtonDisable% := 1;
  Newsflash("Ensure Digitimer is at 1.20x M-Max Intensity",30,0,05,1); 'Trial start
for i%:=0 to 4 do
    FrontView(mMaxData%);
    SampleKey(d$);
    Newsflash("Well that was stimulating!",10,0,05,1);                              'Trial rest duration
next;
    SampleStop();
    View(mMaxData%).FileSaveAs(print$("%s_mMax", subjectID$), -1);
    FileClose(-1,0);
    ButtonDisable% := 0;
return 1;                    ' and stay in current toolbar
end;
'----------------------------------------------------------------------------------------------------------------------
' Find Max Voluntary Contraction
'----------------------------------------------------------------------------------------------------------------------
func MVC%()
if (MVCData%>0) then                      ' If there is already a data view open...
  View(MVCData%);                       ' ...close it
  FileClose(0, -1);                             ' No point setting data% to 0...
endif;

MVCData%:=FileNew(0,0);                 ' Open a new data file for sampling
if MVCData%<0 then
    SampleStop();
  FileClose(-1,-1);
  MVCData%:=FileNew(0,0);
    if MVCData%<0 then
        Message("Unable to open new data file");Halt;
    endif;
endif;

cScale := ChanScale(5);
cOffset := ChanOffset(5);
View(MVCData%).XRange(-1);
View(MVCData%).YRange(5,((-1*cScale)+ cOffset),(1*cScale)+cOffset);
View(MVCData%).WindowVisible(1);
View(MVCData%).DrawMode(-1,3);              'Set event draw mode to lines (3 for waveform)
View(MVCData%).Window(0,0,60,80);            'Make data window right half of screen
ChanHide(1);ChanHide(2);ChanHide(3);ChanHide(4);ChanHide(6);ChanHide(7);ChanHide(8);ChanHide(9);ChanHide(10);ChanHide(30);ChanHide(31);ChanHide(32);
'-------------------------------------------------
'Force Feedback Bar Graph
'-------------------------------------------------
View(MVCData%);
ForceFeedbackBarGraph%:=SetResult(1,1,0,"Force Level","");
FrontView(ForceFeedbackBarGraph%);
View(ForceFeedbackBarGraph%).XRange(0,1);
View(ForceFeedbackBarGraph%).YRange(1,0,10);      'Set Y range to match source waveform channel
View(ForceFeedbackBarGraph%).Window(60,0,100,80); 'Make bar graph window right 40% of screen
Colour(12,6);
FrontView(LogHandle());              'Bring the Log view to the front
View(LogHandle()).Window(0,80,100,100); 'Make bar graph window right 40% of screen
FrontView(ForceFeedbackBarGraph%);          'Bring the bar graph results view to the front
FrontView(MVCData%);                  'Bring the data view to the frontFrontView(MVCData%);          'Bring the data view to the front
Protocol$ := "REC_MVC";
Trial%:=0; 'Set Trial number to zero before recording starts
UpperEMGLimit:=9;
LowerEMGLimit:=1;
SampleStart(); 'begin sampling

ChanProcessAdd(5, 8, 0.2); 'add a 200ms RMS averaging filter

Newsflash("Begin Max Contraction in 5... 4... 3... 2... GO!",6,0,05,1); 'Trial start
MVCstartTime[Trial%]:=View(MVCdata%).Maxtime();
sTime:=View(MVCdata%).Maxtime();
var cd%[1];
cd%[0]:= 100;
SampleText("MVC", -1, cd%[]);
CursorNew((sTime - 1),1);
return 1;                    ' and stay in current toolbar
end;

func MVCrest%()

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''sub func to use active cursor for MVC value search'''''''''''''''''
var ActvCursorTime;
CursorDelete(-1);                   'delete all cursors
CursorNew((sTime - 1),1);           'update cursor(1) position to new start time
CursorNew(cursor(1)+1,2);           'update cursor(2) position to 1 sec after cursor(1)
CursorActive(2, 1, 5, "Cursor(1)", "Cursor(1)+7"); 'make cursor(2) search for max value on chan 5 within 7 seconds of cursor(1)
CursorSearch(2);                    'start cursor 2 search
ActvCursorTime:= Cursor(2);         'get cursor(2) time
docase                              'measure average Y value on channel 5 over 500ms around cursor(2)
case Trial% = 0 then                'three separate variables for max value
    activeMVC_one:=ChanMeasure(5, 2, ActvCursorTime-.25, ActvCursorTime+.25); 
case Trial% = 1 then
    activeMVC_two:=ChanMeasure(5, 2, ActvCursorTime-.25, ActvCursorTime+.25);
case Trial% = 2 then
    activeMVC_three:=ChanMeasure(5, 2, ActvCursorTime-.25, ActvCursorTime+.25);
    activeFxAvg:= (activeMVC_one + activeMVC_two + activeMVC_three) / 3;
endcase;
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

  FindMVC();
  Newsflash("Well done! Now Rest",85,0,05,1);                      'Trial rest duration
  if Trial% < 2 then
    Newsflash("Prepare for next contraction",2,0,05,1);
    Newsflash("Begin Max Contraction in 5... 4... 3... 2... GO!",6,0,05,1); 'Trial start
    sTime:=View(MVCdata%).Maxtime();
    var cd%[1];
    cd%[0]:= 100;
    SampleText("MVC", -1, cd%[]);
  endif;
  if Trial% = 2 then
    Protocol$:="Stopped";    
    SampleStop();
    View(MVCData%).FileSaveAs(print$("%s_MVC", subjectID$), -1);
    FileClose(-1,0);
  endif;
return 1;                    ' and stay in current toolbar
end;

func FindMVC()
var MVC, avgMVC, i%, BicepMVC;
const nMax% := 6000;           'MVC Trial bin length
'Arrays for forces and moments of each trial
var BicepArray[nMax%], TricepArray[nMax%];
FrontView(MVCdata%);
view(MVCdata%).ChanData(5, BicepArray, MVCstartTime[Trial%]+6, MVCendTime[Trial%]);
view(MVCdata%).ChanData(2, TricepArray, MVCstartTime[Trial%]+6, MVCendTime[Trial%]);
var ForceMomentIn[6000][6]; 'Turn vectors into single Force/Moment matrix
var BicepArrayFFS[6000][1];
var MVCIndexEMG%;
var ConvertedFxMVC,ConvertedFyMVC,ConvertedFzMVC,ConvertedMxMVC,ConvertedMyMVC,ConvertedMzMVC;
'get a running average of FMout and FMin over 0.5sec
var rolling;
for i%:=0 to nMax%-501 do
    ArrSum(BicepArray[i%:500],AvgBicep[i%]);
    rolling:=MVCstartTime[Trial%]+6+(i%/1000);
    BicepRMS[i%]:=ChanMeasure(5, 11, rolling, rolling+0.5);'view(pVAdata%).ChanMeasure(1, 11, rolling, rolling+0.5);
    FxArray[i%]:=ChanMeasure(3, 11, rolling, rolling+0.5);
    FyArray[i%]:=ChanMeasure(4, 11, rolling, rolling+0.5);
    FzArray[i%]:=ChanMeasure(5, 11, rolling, rolling+0.5);
    MxArray[i%]:=ChanMeasure(8, 11, rolling, rolling+0.5);
    MyArray[i%]:=ChanMeasure(9, 11, rolling, rolling+0.5);
    MzArray[i%]:=ChanMeasure(10, 11, rolling, rolling+0.5);
next;
'find location of MVC from smoothed data and adjust its location
MVCIndexEMG%:=Max(BicepRMS[])+251;
ArrConst(TrialBicepMVC[Trial%][],BicepRMS[MVCIndexEMG%]);
ArrConst(TrialFxMVC[Trial%][],FxArray[MVCIndexEMG%]);
ArrConst(TrialFyMVC[Trial%][],FyArray[MVCIndexEMG%]);
ArrConst(TrialFzMVC[Trial%][],FzArray[MVCIndexEMG%]);
ArrConst(TrialMxMVC[Trial%][],MxArray[MVCIndexEMG%]);
ArrConst(TrialMyMVC[Trial%][],MyArray[MVCIndexEMG%]);
ArrConst(TrialMzMVC[Trial%][],MzArray[MVCIndexEMG%]);
BicepMVC:=0;
MVC:=0;
for i%:= 0 to Trial% do
    BicepMVC:=TrialBicepMVC[Trial%][0]+BicepMVC;
next;
'avgBicepMVC:=BicepMVC/(Trial%+1);
docase
  case Trial% = 0 then
    avgBicepMVC:= (TrialBicepMVC[0][0])/1;
    UpperEMGLimit:= avgBicepMVC*1.5;
    LowerEMGLimit:= avgBicepMVC*0.95;
'    printlog("1st MVC: %f\n", avgBicepMVC);
  case Trial% = 1 then
    avgBicepMVC:= (TrialBicepMVC[0][0] + TrialBicepMVC[1][0])/2;
    UpperEMGLimit:= avgBicepMVC*1.5;
    LowerEMGLimit:= avgBicepMVC*0.95;
    '    printlog("Avg MVC: %f\n", avgBicepMVC);
  case Trial% = 2 then
    avgBicepMVC:= (TrialBicepMVC[0][0] + TrialBicepMVC[1][0] + TrialBicepMVC[2][0])/3;
    avgFxMVC:= (TrialFxMVC[0][0] + TrialFxMVC[1][0] + TrialFxMVC[2][0])/3;
    avgFyMVC:= (TrialFyMVC[0][0] + TrialFyMVC[1][0] + TrialFyMVC[2][0])/3;
    avgFzMVC:= (TrialFzMVC[0][0] + TrialFzMVC[1][0] + TrialFzMVC[2][0])/3;
    avgMxMVC:= (TrialMxMVC[0][0] + TrialMxMVC[1][0] + TrialMxMVC[2][0])/3;
    avgMyMVC:= (TrialMyMVC[0][0] + TrialMyMVC[1][0] + TrialMyMVC[2][0])/3;
    avgMzMVC:= (TrialMzMVC[0][0] + TrialMzMVC[1][0] + TrialMzMVC[2][0])/3;
    Convert(avgFxMVC,avgFyMVC,avgFzMVC,avgMxMVC,avgMyMVC,avgMzMVC);
    ConvertedFxMVC:= avgFMarray[0][0]; ConvertedFyMVC:= avgFMarray[0][1]; ConvertedFzMVC:= avgFMarray[0][2];
    ConvertedMxMVC:= avgFMarray[0][3]; ConvertedMyMVC:= avgFMarray[0][4]; ConvertedMzMVC:= avgFMarray[0][5];
    printlog("Avg Force in X: %f, Moment in X: %f\n", ConvertedFxMVC,ConvertedMxMVC);
    printlog("Avg Force in Y: %f, Moment in Y: %f\n", ConvertedFyMVC,ConvertedMyMVC);
    printlog("Avg Force in Z: %f, Moment in Z: %f\n", ConvertedFzMVC,ConvertedMzMVC);
    printlog("Sensor Voltage in Z: %f\n", avgFzMVC);
    printlog("active cursor Fz measurements: %f, %f, %f, avg: %f\n", activeMVC_one, activeMVC_two, activeMVC_three, activeFxAvg);
endcase    
UpperEMGLimit:=(avgBicepMVC*1.5);
LowerEMGLimit:=(avgBicepMVC*0.95);
return 1;
end;
proc Convert(avgFxMVC,avgFyMVC,avgFzMVC,avgMxMVC,avgMyMVC,avgMzMVC)
var VtoFM[6][6];
avgFMarray[0][0]:=avgFxMVC;
avgFMarray[0][1]:=avgFyMVC;
avgFMarray[0][2]:=avgFzMVC;
avgFMarray[0][3]:=avgMxMVC;
avgFMarray[0][4]:=avgMyMVC;
avgFMarray[0][5]:=avgMzMVC;
if Sensor% = 0 then
    VtoFM[0][0]:= 26.641;  VtoFM[0][1]:=  0.343;  VtoFM[0][2]:=  0.229;  VtoFM[0][3]:=  0.219;  VtoFM[0][4]:= -0.409;  VtoFM[0][5]:= -0.160; 
    VtoFM[1][0]:= -0.490;  VtoFM[1][1]:= 26.670;  VtoFM[1][2]:=  0.760;  VtoFM[1][3]:=  0.648;  VtoFM[1][4]:= -0.612;  VtoFM[1][5]:=  0.250; 
    VtoFM[2][0]:=  1.828;  VtoFM[2][1]:=  0.187;  VtoFM[2][2]:= 53.235;  VtoFM[2][3]:=  0.076;  VtoFM[2][4]:=  0.204;  VtoFM[2][5]:=  1.989; 
    VtoFM[3][0]:=  0.018;  VtoFM[3][1]:=  0.005;  VtoFM[3][2]:=  0.000;  VtoFM[3][3]:=  2.105;  VtoFM[3][4]:=  0.002;  VtoFM[3][5]:= -0.030; 
    VtoFM[4][0]:=  0.009;  VtoFM[4][1]:= -0.065;  VtoFM[4][2]:=  0.007;  VtoFM[4][3]:= -0.003;  VtoFM[4][4]:=  2.131;  VtoFM[4][5]:=  0.043; 
    VtoFM[5][0]:=  0.032;  VtoFM[5][1]:= -0.007;  VtoFM[5][2]:=  0.007;  VtoFM[5][3]:= -0.008;  VtoFM[5][4]:= -0.042;  VtoFM[5][5]:=  2.116; 
endif;
ArrMul(avgFMarray[][],VtoFM[][]);

end;
'----------------------------------------------------------------------------------------------------------------------
' Sampling function for finding TMS resting/active motor threshold
'----------------------------------------------------------------------------------------------------------------------
func LocateMT%()
Protocol$:= "find rMT";
View(LogHandle());            'Make log view the current view
Window(0,80,100,100);         'Display it at the bottom of the screen
WindowVisible(1);             'Make it visible

if (findrMTdata%>0) then                      ' If there is already a data view open...
  View(findrMTdata%);                       ' ...close it
  FileClose(0, -1);                             ' No point setting data% to 0...
endif;

findrMTdata%:=FileNew(0,0);                 ' Open a new data file for sampling
if findrMTdata%<0 then
    SampleStop();
  FileClose(-1,-1);
  findrMTdata%:=FileNew(0,0);
    if findrMTdata%<0 then
        Message("Unable to open new data file");Halt;
    endif;
endif;

cScale := ChanScale(curChan%);
cOffset := ChanOffset(curChan%);
View(findrMTdata%).XRange(-1);
View(findrMTdata%).YRange(1,(-100),(100));
View(findrMTdata%).YRange(2,(-100),(100));
View(findrMTdata%).WindowVisible(1);
View(findrMTdata%).DrawMode(-1,3);              'Set event draw mode to lines (3 for waveform)
View(findrMTdata%).Window(0,0,60,80);            'Make data window right half of screen

ChanHide(31);ChanHide(3);ChanHide(4);ChanHide(5);ChanHide(6);ChanHide(7);ChanHide(8);ChanHide(9);ChanHide(10);

ViewTrigger(11, .05, .25, 1,1); 'reset the view after each trigger'
resultViewH%:=SetResult(600, BinSize(1), -.1, "Filtered EMG", "s", ChanUnits$(1), "Time", "Bicep EMG");
View(resultViewH%).DrawMode(1, 3);
View(resultViewH%).YRange(1,((-1*cScale)+cOffset),(1*cScale)+cOffset);
View(resultViewH%).WindowVisible(1);
View(resultViewH%).CursorNew(XToBin(0));
View(resultViewH%).Window(0,0,60,80); 'Make EMG results graph window sit between log view and sampling data
Colour(12,6);
'rMT Peak-to-Peak Bar Graph
'-----------------------------
View(findrMTdata%); ' View sampling data
rMTBarGraph%:=SetResult(3,1,0,"M-wave Level","");
View(rMTBarGraph%).XRange(0,3);
View(rMTBarGraph%).YRange(1,0,100);      'Set Y range to match source waveform channel
View(rMTBarGraph%).Window(60,0,100,80); 'Make bar graph window right portion of screen
FrontView(rMTBarGraph%);
Colour(12,6);
FrontView(LogHandle());              'Bring the Log view to the front
FrontView(rMTBarGraph%);                  'Bring the bar graph results view to the front
FrontView(findrMTdata%);          'Bring the data view to the front



' here are all the variables we need to re-initialize every time we start a new recording
sTime := 0;
currentTrigTime:=-1;
updateNecessary%:=0;
stimcount% := 0;

SampleStart();                                  ' Start sampling
ButtonDisable% := 1;           'disable buttons
return 1;                    ' and stay in current toolbar
end;

func DoTMSAnalyze%()
    var curPeakToPeak;
    view(resultViewH%); 'make sure we are looking at the results view, otherwise we get peak-to-peak of the same sampled data every time
    curPeakToPeak:=PeakToPeak(.005,.1); 'peak should be within ~100ms of stim'
    printlog("Current MEP: %d\n", curPeakToPeak);
return 1;                    ' and stay in current toolbar
end;

'----------------------------------------------------------------------------------------------------------------------
'----------------------------------------------------------------------------------------------------------------------
' Cutaneous Reflex Response functions
'----------------------------------------------------------------------------------------------------------------------
'----------------------------------------------------------------------------------------------------------------------
func cVA%()
if (cVAData%>0) then                      ' If there is already a data view open...
  View(cVAData%);                       ' ...close it
  FileClose(0, -1);                             ' No point setting data% to 0...
endif;

cVAData%:=FileNew(0,0);                 ' Open a new data file for sampling
if cVAData%<0 then
    SampleStop();
  FileClose(-1,-1);
  cVAData%:=FileNew(0,0);
    if cVAData%<0 then
        Message("Unable to open new data file");Halt;
    endif;
endif;
var okay%,which%;
  DlgCreate("Which cortical VA protocol?");
  DlgList(1,"Protocol","Arm Posture|Paired Pulse|Cutaneous Stim");
  DlgButton(0,"Cancel");
  DlgButton(1,"OK");
  okay% := DlgShow(which%);
docase
  case    which% = 0 then
    cVA$ := "Arm Posture";
  case which% = 1 then
    cVA$ := "Paired Pulse";
  case which% = 2 then
    cVA$ := "Cutaneous Stim";    
endcase
if cVA$ = "Paired Pulse" then
    var kk%,ppISI%;
  DlgCreate("Set Stim ISI");
  DlgList(1,"ISI","1.5ms|10ms|30ms"); 
  DlgButton(0,"Cancel");
  DlgButton(1,"OK");
    kk% := DlgShow(ppISI%);
    
    Wait%()
    
  docase
  case    ppISI% = 0 then
    TMSSetIsi%(1, 1.5);
  case ppISI% = 1 then
    TMSSetIsi%(1, 10);
  case ppISI% = 2 then
    TMSSetIsi%(1, 30);   
  endcase
endif
if cVA$ = "Cutaneous Stim" then
    var mkay%,csISI%;
  DlgCreate("Set Stim ISI");
  DlgList(1,"ISI","+70ms|+100ms"); 
  DlgButton(0,"Cancel");
  DlgButton(1,"OK");
    mkay% := DlgShow(csISI%);
  docase
  case csISI% = 0 then
    TMSSetIsi%(1, 100);
  case csISI% = 1 then
    TMSSetIsi%(1, 130);  
  endcase
endif
cScale := ChanScale(curChan%);
cOffset := ChanOffset(curChan%);
View(cVAData%).XRange(-1);
View(cVAData%).YRange(1,((-1*cScale)+ cOffset),(1*cScale)+cOffset);
View(cVAData%).WindowVisible(1);
View(cVAData%).DrawMode(-1,3);              'Set event draw mode to lines (3 for waveform)
View(cVAData%).Window(0,0,60,80);            'Make data window right half of screen
ChanHide(3);ChanHide(4);ChanHide(7);ChanHide(6);ChanHide(8);ChanHide(9);ChanHide(10);ChanHide(30);ChanHide(31);ChanHide(32);
'-------------------------------------------------
'Force Feedback Bar Graph
'-------------------------------------------------
View(cVAData%);
ForceFeedbackBarGraph%:=SetResult(1,1,0,"Force Level","");
FrontView(ForceFeedbackBarGraph%);
View(ForceFeedbackBarGraph%).XRange(0,1);
View(ForceFeedbackBarGraph%).YRange(1,0,1200);      'Set Y range to match source waveform channel
View(ForceFeedbackBarGraph%).Window(60,0,100,80); 'Make bar graph window right 40% of screen
Colour(12,6);
FrontView(LogHandle());              'Bring the Log view to the front
FrontView(ForceFeedbackBarGraph%);          'Bring the bar graph results view to the front
FrontView(cVAData%);                  'Bring the data view to the frontFrontView(MVCData%);          'Bring the data view to the front
Protocol$ := "cVA";
Trial%:=0; 'Set Trial number to zero before recording starts
UpperEMGLimit:=(avgBicepMVC*0.55);
LowerEMGLimit:=(avgBicepMVC*0.45);
  var ok%;
  DlgCreate("Set TMS Intensity");
  DlgInteger(1,"Intensity"  , 1, 100);
  DlgButton(0,"Cancel");
  DlgButton(1,"OK");
  ok% := DlgShow(TMSintensityA);
SampleStart(); 'begin sampling
ButtonDisable% := 1;
RandomTime%();
randomize%();
EffortAdjust%();
ready$:="First Time";
ReadyTime:=view(cVAdata%).Maxtime();
'SetParameters%();
return 1;                    ' and stay in current toolbar
end;
func Randomize%()
if Trial% = 24 then
    Newsflash("All Done!",(10),0,05,1);
    HaltRec%();
    Protocol$:="Stopped";
endif;

rNum%:= round(rand()*5)+1;
docase
  case rNum% = 1 then
    Randomize%();
  case rNum% = 2 then
    if numTwo% < 6 then
      MVClevel$:="50 Percent";
      numTwo%+=1;
    else Randomize%();
    endif;
  case rNum% = 3 then
    if numThree% < 6 then
      MVClevel$:="75 Percent";
      numThree%+=1;
    else Randomize%();
    endif;
  case rNum% = 4 then
    if numFour% < 6 then
      MVClevel$:="100 Percent";
      numFour%+=1;
    else Randomize%();
    endif;
  case rNum% = 5 then
    if numZero% < 6 then
      MVClevel$:="At Rest";
      numZero%+=1;
    else Randomize%();
    endif;
  case rNum% = 6 then
    Randomize%();
endcase;
return 1;                    ' and stay in current toolbar
end;
func EffortAdjust%()
docase
  case MVClevel$="At Rest" then
    UpperEMGLimit:=1;'(avgBicepMVC*0.05);
    LowerEMGLimit:=0;'(avgBicepMVC*0);
    
    View(ForceFeedbackBarGraph%).HCursorDelete(-1);
    View(ForceFeedbackBarGraph%).YRange(1,0,2*avgBicepMVC);
    View(ForceFeedbackBarGraph%).HCursorNew(1,UpperEMGLimit);
    View(ForceFeedbackBarGraph%).HCursorNew(1,LowerEMGLimit);
  case MVClevel$="50 Percent" then
    UpperEMGLimit:=(avgBicepMVC*0.525);
    LowerEMGLimit:=(avgBicepMVC*0.475);
    View(ForceFeedbackBarGraph%).HCursorDelete(-1);
    View(ForceFeedbackBarGraph%).YRange(1,0,2*avgBicepMVC);
    View(ForceFeedbackBarGraph%).HCursorNew(1,UpperEMGLimit);
    View(ForceFeedbackBarGraph%).HCursorNew(1,LowerEMGLimit);
  case MVClevel$="75 Percent" then
    UpperEMGLimit:=(avgBicepMVC*0.775);
    LowerEMGLimit:=(avgBicepMVC*0.725);
    View(ForceFeedbackBarGraph%).HCursorDelete(-1);
    View(ForceFeedbackBarGraph%).YRange(1,0,2*avgBicepMVC);
    View(ForceFeedbackBarGraph%).HCursorNew(1,UpperEMGLimit);
    View(ForceFeedbackBarGraph%).HCursorNew(1,LowerEMGLimit);
  case MVClevel$="100 Percent" then
    UpperEMGLimit:=(avgBicepMVC*1.20);
    LowerEMGLimit:=(avgBicepMVC*0.95);
    View(ForceFeedbackBarGraph%).HCursorDelete(-1);
    View(ForceFeedbackBarGraph%).YRange(1,0,2*avgBicepMVC);
    View(ForceFeedbackBarGraph%).HCursorNew(1,UpperEMGLimit);
    View(ForceFeedbackBarGraph%).HCursorNew(1,LowerEMGLimit);
  endcase;
return 1;                    ' and stay in current toolbar
end;
func Stimulus%()
'Function for doing the proper stimulus for each randomized trial
docase
    case cVA$ = "Arm Posture" then
        TMSTriggerTMS%(1);
    case cVA$ = "Paired Pulse" then
        TMSTriggerTMS%(1);
    case cVA$ = "Cutaneous Stim" then
        TMSTriggerTMS%(1);
        SampleKey(a$);
endcase;
'docase
'  case rNum% = 1 then
'    SampleText("1", -1);
'  case rNum% = 2 then
'    SampleText("2", -1);
'  case rNum% = 3 then
'    SampleText("3", -1);
'  case rNum% = 4 then
'    SampleText("4", -1);
'  case rNum% = 5 then
'    SampleText("5", -1);
'  case rNum% = 6 then
'    SampleText("6", -1);
'  case rNum% = 7 then
'    SampleText("7", -1);
'  case rNum% = 8 then
'    SampleText("8", -1);
'  case rNum% = 9 then
'    SampleText("9", -1);
'  case rNum% = 10 then
'    SampleText("10", -1);
'  case rNum% = 11 then
'    SampleText("11", -1);
'  case rNum% = 12 then
'    SampleText("12", -1);
'  case rNum% = 13 then
'    SampleText("13", -1);
'  case rNum% = 14 then
'    SampleText("14", -1);
'  case rNum% = 15 then
'    SampleText("15", -1);
'  case rNum% = 16 then
'    SampleText("16", -1);
'endcase;
WaitLoop%:=1;
Trial%+=1;
RandomTime%();
randomize%();
EffortAdjust%();
Newsflash("Well that was stimulating!",(rTime-20),0,05,1);  'Trial rest duration
Newsflash("Arm TMS",(10),0,05,1);
SetParameters%();
Newsflash("Get Ready!",(5),0,05,0);
'waitTime:=View(cVAdata%).MaxTime();
'yield(3);
'SetParameters%();
'yield(1);
'ready$:="Yes";
'armTMS%();
return 1                    ' and stay in current toolbar
end

func SetParameters%()
'armTMS%();
'TMSSetRemoteControl%(1);
'yield(4);
if ready$ = "No" then
if DigitimerPulse$ ="Train" then
  setTMSIntensity%(0, 1);
    setTMSIntensity%(TMSintensityA, 2);
    'yield(0);
  docase
    case TMSpulse$ ="+100ms" then
        TMSSetRemoteControl%(MagstimSerialPort%);
        TMSSetIsi%(1, 130);
        SampleKey(p$);
    case TMSpulse$ ="+70ms" then
        TMSSetRemoteControl%(MagstimSerialPort%);
        TMSSetIsi%(1, 100);
        SampleKey(o$);
    'case TMSpulse$ ="+40ms" then
    '    TMSSetRemoteControl%(MagstimSerialPort%);
    '    TMSSetIsi%(1, 70);
    '    SampleKey(i$);
    'case TMSpulse$ ="+0ms" then
    '    TMSSetRemoteControl%(MagstimSerialPort%);
    '    TMSSetIsi%(1, 30);
    '    SampleKey(u$);
    endcase;
endif;
if DigitimerPulse$ ="Single" then
  setTMSIntensity%(TMSintensityA, 1);
  setTMSIntensity%(0, 2);
  TMSSetRemoteControl%(MagstimSerialPort%);
  TMSSetIsi%(1, 0);
    endif;
    endif;
ready$:="Yes";
return 1;                    ' and stay in current toolbar
end;
func RandomTime%()
'if PreviousStim$ ="Painful" then
  rTime:= 90;'round(rand()*120)+60;
'endif;
'if PreviousStim$ = "TMS Only" then
'else
'   rTime:= round(rand()*30)+15;
'endif;
return 1;                    ' and stay in current toolbar
end;

func Back%()                  ' Go back to previous toolbar (or exits script if on outermost toolbar)
if SampleStatus() > -0.5 then
  SampleStop();
    FileClose(-1,0);
    Back%()
endif
return 0                    ' Just leaves the current one
end;

'----------------------------------------------------------------------------------------------------------------------
' Halt recording function
'----------------------------------------------------------------------------------------------------------------------
func HaltRec%()
if ((Protocol$ = "Stopped")) then
    ButtonDisable% := 0;
    return 0
endif;
if ((Protocol$ = "find m-wave")) then
  SampleStop();
  Protocol$ := "Stopped";
    docase
    case Muscle$ = "Biceps" then
        View(mWaveThreshData%).FileSaveAs(print$("%s_BicepsMwave", subjectID$), -1);
    case Muscle$ = "Triceps" then
        View(mWaveThreshData%).FileSaveAs(print$("%s_TricepsMwave", subjectID$), -1);
    case Muscle$ = "MP Stim" then
        View(mWaveThreshData%).FileSaveAs(print$("%s_MP_stim", subjectID$), -1);
    endcase;
  FileClose(-1,0);
  ButtonDisable% := 0;
endif;
if ((Protocol$ = "REC m-wave")) then
  SampleStop();
  Protocol$ := "Stopped";
  View(mMaxData%).FileSaveAs(print$("%s_mMax", subjectID$), -1);
  ButtonDisable% := 0;
  FileClose(-1,0);
endif;
if ((Protocol$ = "REC_MVC")) then
  SampleStop();
  Protocol$ := "Stopped";
  View(MVCData%).FileSaveAs(print$("%s_MVC", subjectID$), -1);
  ButtonDisable% := 0;
  FileClose(-1,0);
endif;
if ((Protocol$ = "find rMT")) then
  SampleStop();
  Protocol$ := "Stopped";
  View(findrMTdata%).FileSaveAs(print$("%s_rMTlocating", subjectID$), -1);
  ButtonDisable% := 0;
  FileClose(-1,0);
endif;
if ((Protocol$ = "cVA")) then
    Protocol$ := "Stopped";
    SampleStop();
  docase
  case cVA$ = "Arm Posture" then
    View(cVAData%).FileSaveAs(print$("%s_ArmPosture_cVA", subjectID$), -1);
  case cVA$ = "Paired Pulse" then
    View(cVAData%).FileSaveAs(print$("%s_PP_cVA", subjectID$), -1);   
  case cVA$ = "Cutaneous Stim" then
    View(cVAData%).FileSaveAs(print$("%s_CS_cVA", subjectID$), -1);
endcase
  ButtonDisable% := 0;
  FileClose(-1,0);
endif;
if ((Protocol$ = "Recruitment Curve")) then
  SampleStop();
  Protocol$ := "Stopped";
  View(Data%).FileSaveAs(print$("%s_RC", subjectID$), -1);
  FileClose(-1,0);
  ButtonDisable% := 0;
endif;
return 1;                    ' and stay in current toolbar
end;
'----------------------------------------------------------------------------------------------------------------------
'----------------------------------------------------------------------------------------------------------------------
' The pVA Record Function (Runs after MVC is found)
'----------------------------------------------------------------------------------------------------------------------
'----------------------------------------------------------------------------------------------------------------------
func pVA%()
Protocol$:="Record pVA"; 'set protocol to reflect that we are doing RECpVA% func
pVAdata%:=FileNew(0,0);                 ' Open a new data file for sampling
if pVAdata%<0 then
    SampleStop();
  FileClose(-1,-1);
  pVAdata%:=FileNew(0,0);
    if pVAdata%<0 then
        Message("Unable to open new data file");Halt;
    endif;
endif;
SampleStart();
'-------------------------------------------------
' Calculate Cursor locations based on MVC data
'-------------------------------------------------
UpperEMGLimit:=(avgBicepMVC*1.05);
LowerEMGLimit:=(avgBicepMVC*0.95);
HCursorDelete(-1);              'Clear any existing cursors
'-------------------------------------------------
View(pVAdata%).XRange(-1);
View(pVAdata%).WindowVisible(1);
View(pVAdata%).DrawMode(-1,3);              'Set event draw mode to lines (3 for waveform)
View(pVAdata%).Window(0,0,60,100);            'Make data window right half of screen
ChanHide(31);
'-------------------------------------------------
'Force Feedback Bar Graph
'-------------------------------------------------
View(pVAdata%);
ForceFeedbackBarGraph%:=SetResult(1,1,0,"MVC Level","");
FrontView(ForceFeedbackBarGraph%);
View(ForceFeedbackBarGraph%).XRange(0,1);
View(ForceFeedbackBarGraph%).YRange(1,0,(2*avgBicepMVC));      'Set Y range to match source waveform channel
View(ForceFeedbackBarGraph%).Window(60,0,100,100); 'Make bar graph window right 40% of screen
Colour(12,6);
HCursorNew(1,UpperEMGLimit);
HCursorNew(1,LowerEMGLimit);
FrontView(LogHandle());              'Bring the Log view to the front
FrontView(ForceFeedbackBarGraph%);          'Bring the bar graph results view to the front
FrontView(pVAdata%);                  'Bring the data view to the front
ChanHide(3);ChanHide(4);ChanHide(5);ChanHide(7);ChanHide(11);ChanHide(8);ChanHide(10);ChanHide(30);ChanHide(31);ChanHide(32);
return 1;
end;
'----------------------------------------------------------------------------------------------------------------------
' Find Interpolated Twitch
'----------------------------------------------------------------------------------------------------------------------
func getTwitchAmp()
var i%,PreTwitchAmp,MVCtwitchIndex%,MVCtwitchTime,RestingTwitchTime,TrialVA,RestingTwitchAmp,RestingTime;
var curTwitch[300];'
counter%:=0;
'if getTwitch% = 1 then
    Newsflash("Well Done! Now rest.",6,0,05,1);                              'Trial rest duration
    seconds(0,1);
    WaitTime:=25;
    'Waiting%();
    PreTwitchAmp:=ChanMeasure(5,11,currentTrigTime - .15,currentTrigTime - .05)
    view(pVAdata%).ChanData(5, curTwitch, currentTrigTime + .05, currentTrigTime + .35); 'Fill array with 300ms of data around twitch
    MVCtwitchIndex%:=Max(curTwitch[]); 'find index of twitch max
    MVCtwitchTime:= (currentTrigTime + .05 + (MVCtwitchIndex%/1000)); 'convert index of twitch max to time in ms
    MVCtwitchAmp:=ChanMeasure(5,11,MVCtwitchTime-0.25,MVCtwitchTime+.025);' RMS Amplitude over 50ms of Mz at twitch max amp
    MVCtwitchPP:=MVCtwitchAmp - PreTwitchAmp;
    getTwitch%:=0;
    MVCtwitchArr[TwitchTrial%]:=MVCtwitchPP;
    'MVCtwitchTimeArr[TwitchTrial%]:=MVCtwitchTime;

      SampleKey(d$);                                              'Trigger digitimer for resting twitch
            RestingTwitchTime:=View(pVAdata%).Maxtime();
PreTwitchAmp:=ChanMeasure(5,2,RestingTwitchTime - .15,RestingTwitchTime - .1);
    yield(1);
    view(pVAdata%).ChanData(5, curTwitch, RestingTwitchTime + .05, RestingTwitchTime + .35); 'Fill array with 300ms of data around twitch
var RestTwitch[300]; 'Turn vectors into single Force/Moment matrix
ArrConst(RestTwitch[],curTwitch);
    RestingTwitchIndex%:=Max(RestTwitch[]); 'find index of twitch max
    RestingTime:= (RestingTwitchTime - .05 + (RestingTwitchIndex%/1000)); 'convert index of twitch max to time in ms
    RestingTwitch:=ChanMeasure(5,11,RestingTime-.025,RestingTime+.025);' RMS Amplitude over 50ms of Mz at twitch max amp
    RestingTwitchPP:=RestingTwitch - PreTwitchAmp;
    RestingTwitchArr[TwitchTrial%]:=RestingTwitchPP;
'    getRestingTwitch%:=0;
    'return RestingTwitchArr[];
    '--------------
    'Get VA% as (MVC_Twitch/Resting_Twitch)*100
    '--------------
    TrialVA:= MVCtwitchPP/RestingTwitchPP*100;
    VA_Arr[TwitchTrial%]:=TrialVA;
    'seconds(0,1);
    'WaitTime:=85;
    'Waiting%();
    Newsflash("Rest",85,0,05,1);
    TwitchTrial%+=1;
    if TwitchTrial% < 9 then
      Newsflash("Prepare for next contraction",5,0,05,1);
    endif;
    if TwitchTrial% = 9 then
      Protocol$:="Stopped";
      SampleStop();
      var fd%;
      'subjectID$ := View(pVAdata%).FileName$(3);
      View(pVAdata%).FileSaveAs(print$("%s_pVA", subjectID$), -1, 0, "Save analysis as...");
      fd% := FileNew(1);
      if (fd% < 0) then
        printlog("Could not open text file to save data, printing to log window.\n");
        endif;
      if (fd% < 0) then
        printlog("%sSTIM\t%sVAL\n", subjectID$, subjectID$);
      else
        View(fd%).print("%sSTIM\t%sVAL\n", subjectID$, subjectID$);
      endif;
      var j%;
      for j% := 0 to 9 do
          View(fd%).print("%d\t%f\n", i%, VA_Arr[i%]);
          'View(fd%).print("%d\t%f\n", i%, MEPTimeArr[i%]);
        next;
      var ret%;
      if (fd% >= 0) then
        ret% := View(fd%).FileSaveAs(print$("%s%s", subjectID$, "_pVA_TwitchAmps.txt"), 1, 0, "Save analysis as...");
        if (ret% < 0) then
          View(fd%);
          FileClose(0, -1);
        else
          View(fd%);
          FileClose();
        endif;
    View(pVAdata%);
    FileClose(0,-1);
    pVAdata%:=-1;
    'pVAButtonDisable%:= 3; ' When finished recording allow cVA button
    endif;
    return 1;'VA_Arr[];
endif;
end;
'----------------------------------------------------------------------------------------------------------------------
' Idle Functions
'----------------------------------------------------------------------------------------------------------------------
func Idle%()'The Idle routine is called when PC has time
'----------------------------------------------------------------------------------------------------------------------------------------------------'
'----------------------------------------------------------------M-wave Idle Functions------------------------------------------'
'----------------------------------------------------------------------------------------------------------'
if ((Protocol$ = "find m-wave")) then
    if (MwaveThreshdata%>=0) then
      var curTime, eTime, newestEvent;
      FrontView(MwaveThreshData%);
       curTime := View(MwaveThreshdata%).Maxtime();

      if (updateNecessary% and (View(MwaveThreshdata%).Maxtime()-currentTrigTime >= 1)) then
        printlog("Updating view\n");
        updateData();
            DoMwaveAnalyze%();
            if Protocol$ = "Stopped" then
                return 1;
            endif
        updateNecessary%:=0;
      endif;
      newestEvent := View(MwaveThreshdata%).NextTime(TrigEventChan%, currentTrigTime+.1);

      if (newestEvent > currentTrigTime) then
        printlog("newer event found\n");
        printlog("Updating event\n");
        stimcount%+=1;
        currentTrigTime := newestEvent;
        printlog("%f\n",currentTrigTime);
        updateNecessary%:=1;
      endif;
  endif;
endif;
'----------------------------------------------------------------------------------------------------------------------------------------------------'
'----------------------------------------------------------------MVC Idle Functions------------------------------------------'
'----------------------------------------------------------------------------------------------------------'
if ((Protocol$ = "REC_MVC")) then
    FrontView(MVCdata%);
    curTime := View(MVCdata%).Maxtime();
    ForceFeedbackLevel:=view(MVCdata%).ChanMeasure(5,11,curTime-.2,curTime); 'or as RMS amp over the last 200ms
    ArrConst(View(ForceFeedbackBarGraph%).[:1],ForceFeedbackLevel);
    DrawAll();
'-------------------------------------------------------
' Monitor Force levels and do Feedback display colouring
'-------------------------------------------------------
    'if MVCtrial > 0 then
        docase
        case ForceFeedbackLevel < LowerEMGLimit then
            view(ForceFeedbackBarGraph%).ChanColourSet(1, 1, 1, 0, 0); 'Set feedback graph to red if below lower limit and...
            view(ForceFeedbackBarGraph%).ChanColourSet(1, 2, 1, 0, 0);
            'Sound("S!",1+8192);                                        '... play asynchronous sound (DOESNT WORK?)
        case ForceFeedbackLevel > UpperEMGLimit then
            view(ForceFeedbackBarGraph%).ChanColourSet(1, 1, 1, 0, 0); 'Set feedback graph to red if above upper limit and...
            view(ForceFeedbackBarGraph%).ChanColourSet(1, 2, 1, 0, 0);
        else
            view(ForceFeedbackBarGraph%).ChanColourSet(1, 1, 0, 1, 0); 'Set feedback graph to green if between limits
            view(ForceFeedbackBarGraph%).ChanColourSet(1, 2, 0, 1, 0);
        endcase;

        yield(0);
        if curTime - sTime > 6 then
                MVCendTime[Trial%]:=View(MVCdata%).Maxtime();                    'Reset when the last pulse was sent
                MVCrest%();
                Trial%+=1;
        endif;
endif;
'----------------------------------------------------------------------------------------------------------------------------------------------------'
'----------------------------------------------------------------Rec pVA Idle Functions------------------------------------------'
'----------------------------------------------------------------------------------------------------------'
if ((Protocol$ = "Record pVA")) then
    FrontView(pVAdata%);
    if(View(pVAdata%).Maxtime() - currentTrigTime >= 5) then
        curTime := View(pVAdata%).Maxtime();
        ForceFeedbackLevel:=view(pVAdata%).ChanMeasure(5,11,curTime-.2,curTime); 'or as RMS amp over the last 200ms
        ArrConst(View(ForceFeedbackBarGraph%).[:1],ForceFeedbackLevel);
        DrawAll();
'-------------------------------------------------------
' Monitor Force levels and do Feedback display colouring
'-------------------------------------------------------
        EMGlvl:=view(pVAdata%).ChanMeasure(5,11,curTime-.5,curTime);
        docase

        case EMGlvl < LowerEMGLimit then
            view(ForceFeedbackBarGraph%).ChanColourSet(1, 1, 1, 0, 0); 'Set feedback graph to red if below lower limit and...
            view(ForceFeedbackBarGraph%).ChanColourSet(1, 2, 1, 0, 0);
            'Sound("S!",1+8192);                                        '... play asynchronous sound (DOESNT WORK?)
        case EMGlvl > UpperEMGLimit then
            view(ForceFeedbackBarGraph%).ChanColourSet(1, 1, 1, 0, 0); 'Set feedback graph to red if above upper limit and...
            view(ForceFeedbackBarGraph%).ChanColourSet(1, 2, 1, 0, 0);
        else
            view(ForceFeedbackBarGraph%).ChanColourSet(1, 1, 0, 1, 0); 'Set feedback graph to green if between limits
            view(ForceFeedbackBarGraph%).ChanColourSet(1, 2, 0, 1, 0);
        endcase;
'-------------------------------------------------------
' Trigger Digitimer if forces are in desired range
'-------------------------------------------------------
        if  (EMGlvl < UpperEMGLimit and EMGlvl > LowerEMGLimit) then
            yield(0);
            counter%+=1;
            if counter% = 8 then
                'and  FyLVL <= UpperFyLimit and FyLVL >= LowerFyLimit
                'and  FzLVL <= UpperFzLimit and FzLVL >= LowerFzLimit) then  'If force is in target range then....
                SampleKey(d$);                                              'Send pulse to digitimer
                currentTrigTime:=View(pVAdata%).Maxtime();                    'Reset when the last pulse was sent
                'getTwitch%:=1;                                               'Get twitch data
                getTwitchAmp();
            endif;
        else
            counter%:=0;
        endif;
    endif;
endif;
'----------------------------------------------------------------------------------------------------------------------------------------------------'
'----------------------------------------------------------------Find rMT Idle Functions------------------------------------------'
'----------------------------------------------------------------------------------------------------------'
if ((Protocol$ = "find rMT")) then
  FrontView(findrMTData%);
  curTime := View(findrMTdata%).Maxtime();
    if (View(findrMTData%).Maxtime() - TMSlastCommandTime > 0.5) then
      TMSSetRemoteControl%(MagstimSerialPort%);
      'armTMS%();
    endif;
    if (updateNecessary% and (View(findrMTdata%).Maxtime()-currentTrigTime >= .9)) then
        printlog("Updating view\n");
        updateData();
        DoTMSAnalyze%();
        if Protocol$ = "Stopped" then
           return 1;
        endif
        updateNecessary%:=0;
    endif;
  newestEvent := View(findrMTdata%).NextTime(11, currentTrigTime+.1);

  if (newestEvent > currentTrigTime) then
    TMSTriggerTMS%(1);
    stimcount%+=1;
    currentTrigTime := newestEvent;
    printlog("%f\n",currentTrigTime);
    updateNecessary%:=1;
  endif;
endif;
'----------------------------------------------------------------------------------------------------------------------------------------------------'
'---------------------------------------------------------Recruitment Curve Idle Functions------------------------------------------'
'----------------------------------------------------------------------------------------------------------'
if ((Protocol$ = "Recruitment Curve")) then
  FrontView(data%);
  curTime := View(data%).Maxtime();
    if (View(data%).Maxtime() - TMSlastCommandTime > 0.5) then
        TMSSetRemoteControl%(MagstimSerialPort%);
       ' armTMS%();
    endif;
    if updateNecessary% = 0 then
        if (View(data%).Maxtime() - RCstimTime > 5) then
            TMSTriggerTMS%(1);
            RCmark();
            SampleKey(s$);
            RCstimTime:=View(data%).Maxtime();
            RCstimCount%+=1;
            updateNecessary%:=1;
        endif;
    endif;
    if updateNecessary% = 1 then
        if (View(data%).Maxtime() - RCstimTime > 1) then
            updateData();
            curPeakToPeak:=peakToPeak(0.01, 0.10);
            ANALYZErc(curPeakToPeak);
        endif;
    endif;
    if Protocol$ = "Stopped" then
        return 1;
    endif
endif;

'----------------------------------------------------------------------------------------------------------------------------------------------------'
'----------------------------------------------------------------cVA Idle Functions------------------------------------------'
'----------------------------------------------------------------------------------------------------------'
if ((Protocol$ = "cVA")) then
  if (cVAdata%>=0) then
    FrontView(cVAdata%);
    if (View(cVAdata%).Maxtime() - TMSlastCommandTime > 0.5) then
      TMSSetRemoteControl%(MagstimSerialPort%);
    endif;
        if ready$ = "First Time" then
            if view(cVAdata%).Maxtime() - ReadyTime > 2 then
                SetParameters%();
            endif;
        endif;

    curTime := view(cVAdata%).Maxtime();
    ForceFeedbackLevel:=view(cVAdata%).ChanMeasure(5,11,curTime-.2,curTime); 'or as RMS amp over the last 200ms
    ArrConst(View(ForceFeedbackBarGraph%).[:1],ForceFeedbackLevel);
    DrawAll();
'-------------------------------------------------------
' Monitor Force levels and do Feedback display colouring
'-------------------------------------------------------
    EMGlvl:=view(cVAdata%).ChanMeasure(5,11,curTime-.2,curTime);

    docase
    case ForceFeedbackLevel < LowerEMGLimit then
        view(ForceFeedbackBarGraph%).ChanColourSet(1, 1, 1, 0, 0); 'Set feedback graph to red if below lower limit and...
        view(ForceFeedbackBarGraph%).ChanColourSet(1, 2, 1, 0, 0);
        'Sound("S!",1+8192);                                        '... play asynchronous sound (DOESNT WORK?)
    case ForceFeedbackLevel > UpperEMGLimit then
        view(ForceFeedbackBarGraph%).ChanColourSet(1, 1, 1, 0, 0); 'Set feedback graph to red if above upper limit and...
        view(ForceFeedbackBarGraph%).ChanColourSet(1, 2, 1, 0, 0);
    else
        view(ForceFeedbackBarGraph%).ChanColourSet(1, 1, 0, 1, 0); 'Set feedback graph to green if between limits
        view(ForceFeedbackBarGraph%).ChanColourSet(1, 2, 0, 1, 0);
    endcase;
'-------------------------------------------------------
' Trigger Magstim if forces are in desired range
'-------------------------------------------------------

    if ready$ = "Yes" then
'      if MVClevel$ = "At Rest" then
        docase
          case TMSstatus$ = "Not Armed" then
            'TMSSetRemoteControl%(MagstimSerialPort%);
            armTMS%();
            TMSstatus$:= "Arming";
          case TMSstatus$ = "Arming" then
            waitforTMStoArm:= view(cVAdata%).Maxtime();
            TMSstatus$:= "Armed";
            case TMSstatus$ = "Armed" then
                if MVClevel$ = "At Rest" then
                    if WaitLoop% = 1 then   'Wait loop to ensure Magstim has time to arm/charge before firing stimulus
                        TimeOne:=view(cVAdata%).Maxtime();
                        WaitLoop%:=2;
                    endif;
                    if waitLoop% = 2 then
                        TimeTwo:=view(cVAdata%).Maxtime();
                        if TimeTwo - TimeOne < 4 then
                            yield(0)
                        else
                            WaitLoop%:=0;
                            ready$:="No";
                            TMSstatus$:="Not Armed";
                            cVAmark();
                            Stimulus%();
                        endif;
                    endif;
                endif;
                if (View(cVAdata%).Maxtime() - waitforTMStoArm > 2) then
                    if (ForceFeedbackLevel <= UpperEMGLimit and ForceFeedbackLevel >= LowerEMGLimit) then  'If force is in target range then....
                        yield(0);
                        counter%+=1;
                        if counter% >= 20 then
                            ready$:="No";
                            TMSstatus$:="Not Armed";
                            cVAmark();
                            Stimulus%();
                        endif
                    else
                        counter%:=0;
                    endif; 
                endif;
            endcase;
        endif;
'        if MVClevel$ = "At Rest" then
'            if WaitLoop% = 1 then   'Wait loop to ensure Magstim has time to arm/charge before firing stimulus
'                TimeOne:=view(cVAdata%).Maxtime();
'                WaitLoop%:=2;
'            endif;
'            if waitLoop% = 2 then
'                TimeTwo:=view(cVAdata%).Maxtime();
'                if TimeTwo - TimeOne < 4 then
'                    yield(0)
'                else
'                    WaitLoop%:=0;
'                endif;
'                if (ForceFeedbackLevel <= UpperEMGLimit and ForceFeedbackLevel >= LowerEMGLimit) then  'If force is in target range then....
'                    yield(0);
'                    counter%+=1;
'                    if counter% >= 30 then
'                        ready$:="No";
'                        cVAmark();
'                        Stimulus%();
'                    endif
'                else
'                    counter%:=0;
'                endif
'                if MVClevel$ = "50 Percent" then
'                    if (ForceFeedbackLevel <= UpperEMGLimit and ForceFeedbackLevel >= LowerEMGLimit) then  'If force is in target range then....
'                        yield(0);
'                        counter%+=1;
'                        if counter% >= 20 then
'                            ready$:="No";
'                            cVAmark();
'                            Stimulus%();
'                        endif
'                    else
'                        counter%:=0;
'                    endif;
'                endif;
'                if MVClevel$ = "75 Percent" then
'                    if (ForceFeedbackLevel <= UpperEMGLimit and ForceFeedbackLevel >= LowerEMGLimit) then  'If force is in target range then....
'                        yield(0);
'                        counter%+=1;
'                        if counter% >= 20 then
'                            ready$:="No";
'                            cVAmark()
'                            Stimulus%()
'                        endif
'                    else
'                        counter%:=0;
'                    endif;
'                endif;
'                if MVClevel$ = "100 Percent" then
'                    if (ForceFeedbackLevel <= UpperEMGLimit and ForceFeedbackLevel >= LowerEMGLimit) then  'If force is in target range then....
'                        yield(0);
'                        counter%+=1;
'                        if counter% >= 20 then
'                            ready$:="No";
'                            cVAmark()
'                            Stimulus%()
'                        endif
'                    else
'                        counter%:=0;
'                    endif;
'                endif;
'            endif;
'        endif;
    endif;
endif;
if ((Protocol$ = "Stopped")) then
return 1;'Stay in toolbar
endif;
return 1;'Stay in toolbar
end;
'***************************************************
'***************************************************
'TMS controls
func getInterStimulusInterval()
  return interStimulusIntervalMin + Rand()*jitter;
end;
proc fireTMSWithPause()
  var curTime;
  View(data%);
  curTime:=Maxtime();

  if ((curTime >= nextTMSFireTime)) then
    fireTMS%();
    lastTMSFireTime:=curTime;
    nextTMSFireTime:=curTime+getInterStimulusInterval();
  endif;
end;

func armTMS%()
TMSSetRemoteControl%(1);
TMSArmTMS%(1);
return 1;
end;
func setTMSIntensity%(intensity%, whichTMS%)
' the whichTMS% variable applied to which TMS module
' in a paired pulse setup NOT which TMS as win the
' distinction of TMS Magstim 200 versus the old
' Magstim module
TMSSetRemoteControl%(1);
if (whichTMS% = 1) then
    TMSSetIntensity%(1, intensity%);
else
    TMSSetIntensityB%(1, intensity%);
endif;
return 1;
end;

func fireTMS%()
TMSTriggerTMS%(1);
return 1;
end;

func setTMSIntensityPortal%()
curStimOutput%:=Input("Enter new Stimulator Output", curStimOutput%, 0, 100);
setTMSIntensity%(curStimOutput%, 1);
return 1;
end;

func setTMSBIntensityPortal%()
curStimOutput%:=Input("Enter new Stimulator Output", curStimOutput%, 0, 100);
setTMSIntensity%(curStimOutput%, 2);
return 1;
end;

func setISIPortal%()
ISI := Input("Enter new inter-stimulus interval", isi, 0);
TMSSetRemoteControl%(1);
TMSSetIsi%(1, isi);
return 1;
end;
'**********************************************************
'*********************************************************
'Filtering Funcs
proc FILTERexpFilterInit()
  FILTERexpFilterCursorStart% := CursorNew();
  FILTERexpFilterCursorEnd% := CursorNew();
  CursorLabel(4, FILTERexpFilterCursorStart%, "filter start");
  CursorLabel(4, FILTERexpFilterCursorEnd%, "filter end");
  Cursor(FILTERexpFilterCursorStart%, XToBin(.01));
  Cursor(FILTERexpFilterCursorEnd%, XToBin(.1));
end;

proc FILTERsubtractExp(chan%, sTime, eTime)
  var length%;
  var sBin%, eBin%, i%;
  var coefs[3], err;
  View(resultViewH%);
  sBin% := XToBin(sTime);
  eBin% := XToBin(eTime);
  length% := eBin% - sBin%;
  var xs[length%], ys[length%], fitys[length%];
  ArrConst(ys, View(resultViewH%, chan%).[sBin%:length%]);
  ArrConst(xs, BinSize());
  xs[0] := sTime;
  ArrIntgl(xs);
  FitExp(3, ys, xs);
  FitExp(2, 0, -10000000, 100000000);
  FitExp(0, 1, -10000000, 100000000);
  FitExp(1, .01, 0.0001, 100000000);
  var ret%;
  ret% := FitExp(coefs, err);
  docase
  case (ret% = 1) then
    printlog("ERROR: Exp fit did not converge.\n");
  case (ret% = 0) then
    printlog("SUCCESS: Fit converged.\n");
  case (ret% = -1) then
    printlog("ERROR: fit is not improving but value may be ok.\n");
  case (ret% < -1) then
    printlog("ERROR: unknown error occured during fit.\n");
  endcase;
  for i% := 0 to length%-1 do
    fitys[i%] := coefs[0]*exp(-xs[i%]/coefs[1]) + coefs[2];
  next;
  ArrSub(View(resultViewH%, chan%).[sBin%:length%], fitys);

  'display the fit into the second channel
'  ArrConst(View(resultViewH%, 2).[sBin%:length%], fitys);
end;


func remove60Cycle();
'Example script to remove 60Hz from a waveform
'Arrays big enough to hold all the samples from a sweep
' vh% is view handle of current data view
var a[5000],c[5000];
var vh%,mv%,i%,pi;
var srate:=5000.0; 'sampling rate in Hz
var fm:=60.0; 'mains freq in Hz
var st%,ln%,npts;
var amp,ph,th,re,im;
var amp3,ph3,th3,re3,im3;
var amp5,ph5,th5,re5,im5;
pi:=4.0*atan(1.0);
vh%:=View(); 'current view holding sampled data
ArrConst(a[],View(resultViewH%,1).[]);' copy channel 2 to array a[]
'ChanData(filteredWaveformChan%, a[], currentTrigTime - .1, currentTrigTime + .9);

st%:=1000; 'start point in array for resolver
ln%:=5000-st%; 'length of resolve
npts:=ln%;

'Fourier sum via resolver technique
th:=2.0*pi*fm/srate; 'pre-compute fundamental phase parameter
for i%:=0 to 4999 do
 c[i%]:=sin(th*i%);
next;
im:=2.0*arrdot(a[st%:ln%],c[st%:ln%])/npts; 'imag component
for i%:=0 to 4999 do
 c[i%]:=cos(th*i%);
next;
re:=2.0*arrdot(a[st%:ln%],c[st%:ln%])/npts; 'real component
amp:=sqrt(re*re+im*im); ' amplitude
ph:=atan(re,im); ' phase

'now same for 3rd harmonic
th3:=8.0*atan(1.0)*3.0*fm/srate; 'pre-compute phase parameter
for i%:=0 to 4999 do
 c[i%]:=sin(th3*i%);
next;
im3:=2.0*arrdot(a[st%:ln%],c[st%:ln%])/npts;
for i%:=0 to 4999 do
 c[i%]:=cos(th3*i%);
next;
re3:=2.0*arrdot(a[st%:ln%],c[st%:ln%])/npts;
amp3:=sqrt(re3*re3+im3*im3); ' amplitude
ph3:=atan(re3,im3); ' phase

'now same for 5th harmonic
th5:=8.0*atan(1.0)*5.0*fm/srate; 'pre-compute phase parameter
for i%:=0 to 4999 do
 c[i%]:=sin(th5*i%);
next;
im5:=2.0*arrdot(a[st%:ln%],c[st%:ln%])/npts;
for i%:=0 to 4999 do
 c[i%]:=cos(th5*i%);
next;
re5:=2.0*arrdot(a[st%:ln%],c[st%:ln%])/npts;
amp5:=sqrt(re5*re5+im5*im5); ' amplitude
ph5:=atan(re5,im5); ' phase
'printlog("amp,ph 1,2,3  ",amp,"  ",ph,"  ",amp3,"  ",ph3,"  ",amp5,"  ",ph5);
'compute correction wave
for i%:=0 to 4999 do
 c[i%]:=(amp*sin(ph+th*i%)+amp3*sin(ph3+th3*i%)+amp5*sin(ph5+th5*i%));
next;

'subtract the correction, leaving result in a[]
arrsub(a[],c[]);

'gash code to see the result

ArrConst(View(resultViewH%,1).[],a[]);' copy array a[] into view
view(resultViewH%).Draw();
return 1;
end;

func removeDrift%();
' This function just uses the example high-pass filter in the filter bank
' to remove baseline drift
' might do more at a later stage
'View(resultViewH%).FiltApply(3, 1, 1, -.1, .9);
  ArrFilt(View(resultViewH%).[], highPassFilter[]);
  return 1;
end;


'do a short time fft on the data..i guess, thinking this wont work
func sFFT%()
  var dataInterval[128];
  var i%, stopAt%;
  i%:=0;
  stopAt%:=5000-128-1;
'  printlog(stopAt%);
  repeat
    ArrConst(dataInterval[], View(resultViewH%,1).[i%:128]);
    ArrFFT(dataInterval[], 5);
    'printlog(Max(dataInterval[]));
    'printlog(i%);
    i%+=1;
    View(resultViewH%,2).[i%]:=Max(dataInterval[]);
  until i%>=stopAt%;
  return 1;
end;
'*********************************************************
'*********************************************************
' Magstim 200^2 control functions (these use the serial line control)

' **************************************
' TMS Serial port funcs
const MAXBUFSIZE% := 1024;

var numCommandsSent% := 0;
var TMSSerialPortBuf%[MAXBUFSIZE%];

func TMSSendCharString%(port%, mes$)
  return SerialWrite(MagstimSerialPort%, mes$);
end;

func TMSSendOneByteCmd%(port%, command%,commanddata%)
  var ret%;
  var portdata%[3];

  numCommandsSent% := numCommandsSent% + 1;
  portdata%[0] := command%;
  portdata%[1] :=commanddata%;
  portdata%[2] := GetCRC%(portdata%[], 2);
  ret% :=  SerialWrite(MagstimSerialPort%, portdata%[]);

  ' we're going to update when we send the TMS machine commands so we can keep sending
  ' it something at least every 0.5 seconds.  SampleStatus returns the status of our sampling
  ' with a return value of 2 meaning that it is in the process of sampling
  'if (data% > -1 and SampleStatus() = 2) then
    TMSlastCommandTime := View(0).Maxtime();
  'endif;

if (ret% > 0) then
    'return TMSCheckCommand%(port%, command%);
    return 0;
  else
    return ret%;
  endif;
end;

func GetCRC%(data%[], numchars%)
  var i%;
  var sum%;
  sum% := 0;
  for i%:=0 to (numchars%-1) do
    sum% += data%[i%];
  next;
  if (sum% > 0xff) then
    sum% := sum% band 0xff;
  endif;
  sum% := BitWiseComplement%(sum%);
  return sum%;
end;

' cuz Spike is effin retarded, we've got to write our own
func BitWiseComplement%(num%)
  var newnum%;
  newnum% := 0;
  if (not(num% band 0x01)) then
    newnum% += 0x01;
  endif;
  if (not(num% band 0x02)) then
    newnum% += 0x02;
  endif;
  if (not(num% band 0x04)) then
    newnum% += 0x04;
  endif;
  if (not(num% band 0x08)) then
    newnum% += 0x08;
  endif;
  if (not(num% band 0x10)) then
    newnum% += 0x10;
  endif;
  if (not(num% band 0x20)) then
    newnum% += 0x20;
  endif;
  if (not(num% band 0x40)) then
    newnum% += 0x40;
  endif;
  if (not(num% band 0x80)) then
    newnum% += 0x80;
  endif;
  return newnum%;
end;

func TMSOpenConnection%(port%) 'If the code does not appear to run at all, you likely do not have the Magstim connected to the correct serial port (if using serial to USB, it must be plugged into the correct USB port)
var ret%;
ret% := SerialOpen(MagstimSerialPort%, 9600, 8, 0, 1, 0); '9600 is the bit rate
if (ret% < 0) then
    printlog("Error occured in opening serial connection: %d\n", ret%);
    return ret%;
endif;
return 0;
end;

func TMSFlushRecvBuffer%(port%)
  var buf%[1024];
'  while (SerialCount(port%) > 0) do
'    SerialRead(port%, buf%[]);
'  wend;
  if (SerialCount(MagstimSerialPort%) > 0) then
    SerialRead(MagstimSerialPort%, buf%[]);
  endif;
  return 0;
end;

'func TMSGetStatus%(port%) 'Function not currently used, but useful
'  var statusbyte%;
'  TMSFlushRecvBuffer%(port%);
'  if (TMSSendOneByteCmd%(MagstimSerialPort%, 0x4A, 0x40) < 0) then
'    return -1;
'  endif;
'  TMSCheckCommand%(MagstimSerialPort%, 0x4A);
'  printlog("Num chars read: %d\n", SerialRead(port%, statusstr$));
'  SerialRead(port%, statusstr%[]);
'  printlog("status: %s\n", statusstr$);
'  if (statusstr%[0] = 0x4A) then
'    printlog("Status command acknowledged\n");
'  else
'    printlog("Error: status command not acknowledged");
'    return -2;
'  endif;
'
'  statusbyte% := TMSSerialPortBuf%[1];
'  docase
'    case (statusbyte% band 0x01) then
'      printlog("Status: standby\n");
'    case (statusbyte% band 0x02) then
'      printlog("Status: armed\n");
'    case (statusbyte% band 0x04) then
'      printlog("Status: ready\n");
'    else
'      printlog("Status: unknown\n");
'  endcase;
'
'  if (statusbyte% band 0x80) then
'    printlog("Coil: present\n");
'  else
'    if (statusbyte% band 0x10) then
'      printlog("Coil: replace\n");
'    endif;
'  endif;
'
'  if (statusbyte% band 0x20) then
'    if (statusbyte% band 0x40) then
'      printlog("Error: fatal\n");
'    else
'      printlog("Error: non-fatal\n");
'    endif;
'  else
'    printlog("Error: none\n");
'  endif;
'
'  if (statusbyte% band 0x80) then
'    printlog("Remote control: on\n");
'  else
'    printlog("Remote control: off\n");
'  endif;
'  printlog("Power A: %s\n", Chr$(TMSSerialPortBuf%[2]) + Chr$(TMSSerialPortBuf%[3]) + Chr$(TMSSerialPortBuf%[4]));
'  printlog("Power B: %s\n", Chr$(TMSSerialPortBuf%[5]) + Chr$(TMSSerialPortBuf%[6]) + Chr$(TMSSerialPortBuf%[7]));
'  printlog("ISI: %s\n", Chr$(TMSSerialPortBuf%[8]) + Chr$(TMSSerialPortBuf%[9]) + Chr$(TMSSerialPortBuf%[10]));
'  return 0;
'end;

func TMSCheckCommand%(port%, cmd%)
  while (SerialCount(MagstimSerialPort%) < 3) do
    Yield();
  wend;
  if (SerialCount(MagstimSerialPort%) > 0) then
    SerialRead(MagstimSerialPort%, TMSSerialPortBuf%[]);
    if (TMSSerialPortBuf%[0] = Asc("?")) then
      printlog("Error: command not understood\n");
      return -1;
    endif;
    if (TMSSerialPortBuf%[0] = cmd%) then
      printlog("Command acknowledged\n");
    else
      printlog("Command not acknowledged\n");
      return -1;
    endif;
    docase
    case (TMSSerialPortBuf%[1] = Asc("?")) then
      printlog("Error: command data incorrect\n");
      return -1;
    case (TMSSerialPortBuf%[1] = Asc("S")) then
      printlog("Error: command not valid for current status\n");
      return -1;
    else
      printlog("Command completed\n");
      return 0;
    endcase;
  endif;
end;

func TMSSetRemoteControl%(port%)
TMSSendOneByteCmd%(port%, 0x51, 0x40);
TMSSendOneByteCmd%(port%, 0x45, 0x42);
  if (TMSSendOneByteCmd%(MagstimSerialPort%, 0x51, 0x40) < 0) then
    'printlog("Error: could not activate remote control of TMS\n");
    return -1;
  endif;
  return 0;
end;

func TMSSendThreeByteCmd%(port%, cmd%, data$)
  var portdata%[5];
  portdata%[0] := cmd%;
  portdata%[1] := Asc(Mid$(data$,1,1));
  portdata%[2] := Asc(Mid$(data$,2,1));
  portdata%[3] := Asc(Mid$(data$,3,1));
  portdata%[4] := GetCRC%(portdata%[], 4);
  return SerialWrite(MagstimSerialPort%, portdata%[]);
end;

func TMSSetIntensity%(port%, power%)
  if (power% < 0) then
    return -1;
  endif;
  var portdata%;
  var powerstring$;
  powerstring$ := Print$("%03d", power%);
  printlog("Setting TMS intensity: " + powerstring$ + "\n");
  return TMSSendThreeByteCmd%(MagstimSerialPort%, 0x40, powerstring$);
end;

func TMSSetIntensityB%(port%, power%)
  if (power% < 0) then
    return -1;
  endif;
  var portdata%;
  var powerstring$;
  powerstring$ := Print$("%03d", power%);
  printlog("Setting TMS intensity: " + powerstring$ + "\n");
  return TMSSendThreeByteCmd%(MagstimSerialPort%, 0x41, powerstring$);
end;

func TMSSetISI%(port%, isi%)
  if (isi% < 0) then
    return -1;
  endif;
  var timestring$;
  timestring$ := Print$("%03d", isi%);
  printlog("Setting inter-stimulus interval: " + timestring$ + "\n");
  TMSFlushRecvBuffer%(1);
  TMSSendThreeByteCmd%(port%, 0x43, timestring$);
  TMSCheckCommand%(port%, 0x43);
end;

func TMSArmTMS%(port%)
  TMSFlushRecvBuffer%(port%);
    printlog("Arming TMS\n");
    TMSSendOneByteCmd%(port%, 0x45, 0x42);
end;

func TMSTriggerTMS%(port%)
printlog("Triggering TMS\n");
SampleKey(t$);
TMSSendOneByteCmd%(port%, 0x45, 0x48); 'sending it via serial line
end;

func TMSCloseConnection%(port%)
SerialClose(MagstimSerialPort%);
printlog("Number of commands sent: %d\n", numCommandsSent%);
return 0;
end;
'----------------------------------------------------------------------------------------------------------------------'
'------------------------------------------Allow for NewsFlash Message Boxes-------------------------------------------'
'----------------------------------------------------------------------------------------------------------------------'
'  Arguments:
'  msg$                                            ' a string containing the message to display.
'  Tshow                                           ' the delay before the message box closes automatically in seconds (minimum 1.5).
'  x,y                                             ' the coordinates of the message box on the screen.
                                                            '(If x and y are set to 0, the message box will appear in mid-screen)
'  beep%                                            ' If set to 1 then the computer plays a short 'beep' when the message first appears.

var tflash;                                         ' global variable required by NewsFlash() and NFIdle%();
proc NewsFlash(msg$,Tshow,x,y,beep%);           	' floating message box at coordinates with optional audible alert
	var dummy;
		if Tshow < 1.5 then Tshow:=1.5; 																	'set minimum display time
		endif;
	tflash:=Tshow;                                	'tflash is a global variable
		if beep% then
  		Sound("S*",1);                              'beep
		endif;
    Seconds(0); 'reset the clock
    DlgCreate("Info:",x,y);
	DlgLabel(1,msg$);
	DlgAllow(1023,NFIdle%);'Idle routine does the timing
	DlgButton(0,"");'hide cancel button
	DlgShow(dummy);
	return;
end;
'==========
	func NFidle%();'Newsflash idle routine
	var ret%:=1;
	if Seconds() > tflash then' times up 
		ret%:= 0;'             so close message box
	endif;
	return ret%;
	end;
'==========
  '----------------------------------------------------------------------------------------------------------------------'
  '------------------------------------------Recruitment Curve-----------------------------------------------------------'
  '----------------------------------------------------------------------------------------------------------------------'
proc ANALYZErc(curPeakToPeak)	
	var stim%;
	stim% := RCIarray%[RCstimCount%-1];
docase
case stim% = RCintensityA% then
    rcPeakToPeak[0][countA%]:= curPeakToPeak;
    countA%+=1;
case stim% = RCintensityB% then
    rcPeakToPeak[1][countB%]:= curPeakToPeak;
    countB%+=1;
case stim% = RCintensityC% then
    rcPeakToPeak[2][countC%]:= curPeakToPeak;
    countC%+=1;
case stim% = RCintensityD% then
    rcPeakToPeak[3][countD%]:= curPeakToPeak;
    countD%+=1;
case stim% = RCintensityE% then
    rcPeakToPeak[4][countE%]:= curPeakToPeak;
    countE%+=1;
case stim% = RCintensityF% then
    rcPeakToPeak[5][countF%]:= curPeakToPeak;
    countF%+=1;
case stim% = RCintensityG% then
    rcPeakToPeak[6][countG%]:= curPeakToPeak;
    countG%+=1;
case stim% = RCintensityH% then
    rcPeakToPeak[7][countH%]:= curPeakToPeak;
    countH%+=1;
case stim% = RCintensityI% then
    rcPeakToPeak[8][countI%]:= curPeakToPeak;
    countI%+=1;    
endcase;
var coef[3], maxSlope, maxInt;
if RCstimCount% = 54 then
    Protocol$ := "Stopped";
    SampleStop();
    View(Data%).FileSaveAs(print$("%s_RCurve", subjectID$), -1);
    ANALYZEprintResults(maxSlope, maxInt); 'This won't work with current variables (Coef[],maxSlope, maxInt)
    FileClose(0, 1);
else
    nextStim%:=RCIarray%[RCstimCount%];
    TMSSetIntensity%(1, nextStim%);
    updateNecessary%:= 0;
endif;
end;
'*********************************************************
'*********************************************************
' ONLINE recruitment curve analysis functions
'*********************************************************
func RCMeasureInit%()
	ArrConst(valsPerIntensity, 0);
	ArrConst(numPerIntensity%, 0);
	return 1;
end;

func RCMeasure%()
	var slope, intercept, count%, i%, j%, sum;


	i% := 0;


   var coef[3], maxSlope, int;
	'ANALYZEplotFit(coef);
	'ANALYZEmaxSlope(coef, maxSlope, int);
	'ANALYZEprintResults(coef, maxSlope, int);
	return 1;
end;

var ANALYZEfitXs[100];
var ANALYZEfitYs[100];
var ANALYZEnumX%;
var xy% := -1;

proc ANALYZEplotFit(coefs[])

	xy% := FileNew(12, 1);
	var curMax := 0;

		var i%, j%;
		ANALYZEnumX% := 0;
		for i% := 0 to (maxIntensities% - 1) do
			if (0 <> numPerIntensity%[i%]) then
				var fitY;
				var fitX;
				docase
				case (FITuseData% = FITDATAAVG%) then
					var sum;
					sum := 0;
					for j% := 0 to numPerIntensity%[i%]-1 do 
						sum += valsPerIntensity[i%][j%];
					next;

					var avg;
					avg := sum/numPerIntensity%[i%];

					if (avg > curMax) then curMax := avg; endif;	
					fitX := i%;
					fitY := avg;
				case (FITuseData% = FITDATAMEDIAN%) then
					var median, num%;
					fitX := i%;
					fitY := ANALYZEcalcMedian(i%);
				endcase;
				ANALYZEfitXs[ANALYZEnumX%] := fitX;
				ANALYZEfitYs[ANALYZEnumX%] := fitY;
				ANALYZEnumX% += 1;
				XYAddData(1, fitX, fitY);
			endif;
		next;
		FitNLUser(ANALYZEsigmoidFit, 3, ANALYZEnumX%);
		FitNLUser(0, .5, -1000, 1000);
		FitNLUser(1, 50, 0, 100);
		FitNLUser(2, 1, 1, 100);
		var  err, iter%, ret%;
		ret% := FitNLUser(coefs, err, 10000, iter%);
		docase
			case ret% = 1 then
				printlog("ERROR: sigmoid fit did not converge.\n");
			case ret% = 0 then
				' do nothing, fit converged
			case ret% = -1 then
				printlog("WARNING: sigmoid fit stopped improving but convergence not ideal.\n");
		endcase;
		ANALYZEplotSigmoid(coefs);
		XRange(0, 100);
		YRange(0, 0, curMax + curMax*.5);
end;

proc ANALYZEplotSigmoid(coef[])
	var newChan%, i%;
	newChan% := XYSetChan(0, 100, 0, 1, 7);
	XYDrawMode(newChan%, 2, 0);
	for i% := 0 to 100 do
		var y;
		y := coef[0] / (1 + exp(-(i%-coef[1])/coef[2]));
		XYAddData(newChan%, i%, y);
	next;

	var maxSlope, int%;

end;

func ANALYZEmaxSlope(coef[], &slope, &int)
	var a, b, c, cursorNum, i%;
	a := coef[0];
	c := coef[2];
	' the second coef (b) is the point of inflection in the sigmoid
	b := coef[1];


	var maxIntRecorded% := 101;
	' we're going to look through the data and check the max intensity that was recorded
	' if that is less than the inflection point of our model, this means that we did not
	' hit our plateau and hence we're going to evaluate our max slope at the last point
	' we do have
	for i% := 100 to 1 step -1 do
		if (numPerIntensity%[i%] <> 0) then
			maxIntRecorded% := i%;
			i% := -1; 'break out of the loop
		endif;
	next;
	if (b <= maxIntRecorded%) then
		int := b;
		slope := a/c/4;
	else
		int := maxIntRecorded%;
		var w;
		w := (int - b)/c;
		slope := a/c*exp(-w)*Pow(1+exp(-w),-2);
		' TODO: do the right calculation for slope based on our new x
	endif;
	cursorNum := CursorNew(int);
end

func ANALYZEsigmoidFit(ind%, args[], dyda[])
	var a, b, c, z, w, xi, yi, res;
	a := args[0];
	b := args[1];
	c := args[2];
	xi := ANALYZEfitXs[ind%];
	yi := ANALYZEfitYs[ind%];
	z := (xi-b)/c;
	printlog("a: %f, b: %f, c: %f, xi: %f, yi: %f\n", a, b, c, xi, yi);
	w := 1 + exp(-z);

	dyda[0] := Pow(w, -1);
	dyda[1] := -a/c*exp(-z)*pow(w,-2);
	dyda[2] := -a*z/c*exp(-z)*pow(w,-2);
	res     := yi - a*dyda[0];
	return res;
end;

' calculate the average pp for the given intensity
func ANALYZEcalcAvg(int%)


var sum, j%;
sum := 0;
for j% := 0 to 5 do 
    sum += rcPeakToPeak[int%][j%];
next;

var avg;
avg := sum/6;

				
return avg;
end;

' calculate the median value for the given intensity
func ANALYZEcalcMedian(int%)
		var median, num%;		
		num% := 6;
		if (0 <> num%) then
			var vals[num%];
			ArrConst(vals, rcPeakToPeak[int%][0:num%]);
			ArrSort(vals);
			if (num% mod 2 = 0) then
				' we have an even number of values
				' so we have to take the average of the middle two
				median := (vals[num% / 2] + vals[num%/2 - 1]) / 2;
			else
				' we have an odd number of values, so we're going to
				' take the middle one
				median := vals[Trunc(num% / 2)];
			endif; 'even or odd
			return median;
		else
			return -1;
		endif; '0 <> num%
end;

proc ANALYZEprintResults(maxSlope, maxInt)'(coef[], maxSlope, maxInt)
	View(LogHandle());
	EditSelectAll();						'Select all text in log view
	EditClear();							'Delete it
	var fd%;
	'subjectID$ := View(data%).FileName$(3);
	fd% := FileNew(1);
	if (fd% < 0) then
		printlog("Could not open text file to save data, printing to log window.\n");
	endif;
	if (fd% < 0) then
		printlog("%sSTIM\t%sVAL\n", subjectID$, subjectID$);
	else
		View(fd%).print("%sSTIM\t%sVAL\n", subjectID$, subjectID$);
	endif;
	var i%, j%;
	for i% := 0 to 8 do
		for j% := 0 to 5 do
			View(fd%).print("%d\t%f\n", i%, rcPeakToPeak[i%][j%]);
		next;
		View(fd%).print("%s\t%f\n", print$("%dmedian", i%), ANALYZEcalcMedian(i%));
        View(fd%).print("%s\t%f\n", print$("%davg", i%), ANALYZEcalcAvg(i%));
        View(fd%).print("%s\t%f\n", print$("%dintensity", i%), RCintensity%[i%]);
    next;
    for i% := 0 to 54 do 
        View(fd%).print("%s\t%f\n", print$("%d", i%), RCIarray%[i%]);
    next;
	'View(fd%).print("coefA\t%f\n", coef[0]);
	'View(fd%).print("coefB\t%f\n", coef[1]);
	'View(fd%).print("coefC\t%f\n", coef[2]);
	'View(fd%).print("MaxSlope\t%f\n", maxSlope);
	'View(fd%).print("MaxSlopeInt\t%f\n", maxInt);
	var ret%;	
	if (fd% >= 0) then 
		ret% := View(fd%).FileSaveAs(print$("%s_RC_analyze.txt", subjectID$), 1, 0, "Save analysis as...");
		if (ret% < 0) then
			View(fd%);
			FileClose(0, -1);
		else
			View(fd%);
			FileClose();
		endif;
		'View(xy%);
		'ret% := View(xy%).FileSaveAs(print$("%s%s", subjectID$, "_RC_plot.bmp"), 13, 0, "Save plot as ...");

	endif;
end;
'**********************************************************
'*********************************************************
func Wait%()

armTMS%();   'arm the magstim
var btime,ftime;
btime:=view(0).MaxTime() + 5; 'begin time 

while btime < ftime do         'give magstim a second to arm itself before attempting to change the ISI
    ftime := view(0).MaxTime();
    if (View(0).Maxtime() - TMSlastCommandTime > 0.5) then 'make sure that spike is still communicating with the magstim
      TMSSetRemoteControl%(MagstimSerialPort%);
    endif;    
wend;

end
func actualRC%()
Protocol$:="Recruitment Curve";
View(LogHandle());						'Make log view the current view
EditSelectAll();						'Select all text in log view
EditClear();							'Delete it
Window(0,80,100,100);					'Display it at the bottom of the screen
WindowVisible(1);						'Make it visbible

if (data%>0) then							'If there is already a data view open then
  View(data%);							'Close it
  FileClose(0, -1);
endif;

data%:=FileNew(0,0);					'Open a new data file for sampling


if data%<0 then 
	SampleStop();
	FileClose(-1,-1);
	data%:=FileNew(0,0);
	if data%<0 then
		Message("Unable to open new data file.  You might have to reboot.");Halt;
	endif;
endif;

View(data%).XRange(0, 1);
View(data%).Window(0,0,60,80);
ChanHide(3);ChanHide(4);ChanHide(5);ChanHide(7);ChanHide(6);ChanHide(8);ChanHide(9);ChanHide(10);ChanHide(30);ChanHide(31);ChanHide(32);
ViewTrigger(11, .1, .9, 1,1);

DrawMode(-1,2);							'Set event draw mode to lines
'Window(0,0,100,80);						'Make data window in top bit of screen

resultViewH%:=SetResult(5000, BinSize(1), -.1, "Filtered EMG", "s", ChanUnits$(1), "Time", "EMG-apb");
View(resultViewH%).DrawMode(1, 2);
View(resultViewH%).YRange(1, -1.0, 1.0);
View(resultViewH%).WindowVisible(1);
View(resultViewH%).CursorNew(XToBin(0));
View(resultViewH%).Window(0,0,100,80);
Colour(12,6);
View(data%); ' View sampling data
rcBarGraph%:=SetResult(3,1,0,"M-wave Level","");
View(rcBarGraph%).XRange(0,3);
View(rcBarGraph%).YRange(1,0,200);      'Set Y range to match source waveform channel
View(rcBarGraph%).Window(60,0,100,80); 'Make bar graph window right portion of screen

FrontView(resultViewH%);
' here are all the variables we need to re-initialize every time we start a new recording
currentTrigTime:=-1;
updateNecessary%:=0;

nextTMSFireTime := 4;
TMSlastCommandTime := -1;


  	DlgCreate("RC Parameters"); 'get rMT to base RC intensities off of
  	DlgInteger(1, "rMT", 0, 100);

    DlgShow(rMT%);

if rMT% > 62 then rMT%:= 62; endif; 'ensure high end does not go above 100% of stimulator intensity



RCintensityA%:= round(rMT%*0.8); 'Low end of RC intensities is 80% of rMT 
RCintensityB%:= round(rMT%*0.9);
RCintensityC%:= round(rMT%*1.0);
RCintensityD%:= round(rMT%*1.1);
RCintensityE%:= round(rMT%*1.2);
RCintensityF%:= round(rMT%*1.3);
RCintensityG%:= round(rMT%*1.4);
RCintensityH%:= round(rMT%*1.5);
RCintensityI%:= round(rMT%*1.6); 'High end of RC intensities is 160% of rMT
var i%;
for i% := 0 to 8 do 
    RCintensity%[i%]:= round(rMT%*(0.8+(i%*.10))); 'setup array of intensity values instead of individual variables (used in print/save function)
next;

RandomizeRC%(); 'create randomized order of stimulus intensities for RC

SampleStart();

Wait%();
TMSSetIntensity%(1, RCIarray%[0]);

return 1;
end;
func RandomizeRC%()
var pick%;
    pick%:= round(rand()*10)+1;

if place% = 0 then      'set first intensity to 1 because first instance does not fire
    RCIarray%[0]:= 1;
endif

if place% < 54 then 
    
docase
  case pick% = 1 then
       RandomizeRC%();
  case pick% = 2 then
    if intA% < 6 then
      RCIarray%[place%]:= RCintensityA%;
        intA%+=1;
        place%+=1;
        RandomizeRC%();    
    else RandomizeRC%();
    endif;
  case pick% = 3 then
    if intB% < 6 then
      RCIarray%[place%]:= RCintensityB%;
        intB%+=1;
        place%+=1;
        RandomizeRC%();    
    else RandomizeRC%();
    endif;
    case pick% = 4 then
    if intC% < 6 then
      RCIarray%[place%]:= RCintensityC%;
        intC%+=1;
        place%+=1;
        RandomizeRC%();    
    else RandomizeRC%();
    endif;        
    case pick% = 5 then
    if intD% < 6 then
      RCIarray%[place%]:= RCintensityD%;
        intD%+=1;
        place%+=1;
        RandomizeRC%();    
    else RandomizeRC%();
    endif;          
    case pick% = 6 then
    if intE% < 6 then
      RCIarray%[place%]:= RCintensityE%;
        intE%+=1;
        place%+=1;
        RandomizeRC%();    
    else RandomizeRC%();
    endif;         
    case pick% = 7 then
    if intF% < 6 then
      RCIarray%[place%]:= RCintensityF%;
        intF%+=1;
        place%+=1;
        RandomizeRC%();    
    else RandomizeRC%();
    endif;         
    case pick% = 8 then
    if intG% < 6 then
      RCIarray%[place%]:= RCintensityG%;
        intG%+=1;
        place%+=1;
        RandomizeRC%();    
    else RandomizeRC%();
    endif; 
    case pick% = 9 then
    if intH% < 6 then
      RCIarray%[place%]:= RCintensityH%;
        intH%+=1;
        place%+=1;
        RandomizeRC%();    
    else RandomizeRC%();
    endif;         
    case pick% = 10 then
    if intI% < 6 then
      RCIarray%[place%]:= RCintensityI%;
        intI%+=1;
        place%+=1;
        RandomizeRC%();    
    else RandomizeRC%();
    endif;         
    case pick% = 11 then
    RandomizeRC%();               
endcase;
endif;    
return 1;
end
func RCmark()
if RCstimCount% >= 1 then
var stim%;
var cd%[1];
	stim% := RCIarray%[RCstimCount%-1];
docase
case stim% = RCintensityA% then
    cd%[0] := 1;
    SampleText("1", -1, cd%[]);
case stim% = RCintensityB% then
    cd%[0] := 2;
    SampleText("2", -1, cd%[]);
case stim% = RCintensityC% then
    cd%[0] := 3;
    SampleText("3", -1, cd%[]);
case stim% = RCintensityD% then
    cd%[0] := 4;
    SampleText("4", -1, cd%[]);
case stim% = RCintensityE% then
    cd%[0] := 5;
    SampleText("5", -1, cd%[]);
case stim% = RCintensityF% then
    cd%[0] := 6;
    SampleText("6", -1, cd%[]);
case stim% = RCintensityG% then
    cd%[0] := 7;
    SampleText("7", -1, cd%[]);
case stim% = RCintensityH% then
    cd%[0] := 8;
    SampleText("8", -1, cd%[]);
case stim% = RCintensityI% then
    cd%[0] := 9;
    SampleText("9", -1, cd%[]); 
    endcase;
endif;
end;
func cVAmark()
var cd%[1];
docase
case MVClevel$ = "At Rest" then
    cd%[0] := 1;
    SampleText("At_Rest", -1, cd%[]);
case MVClevel$ = "50 Percent" then
    cd%[0] := 2;
    SampleText("50_Percent", -1, cd%[]);
case MVClevel$ = "75 Percent" then
    cd%[0] := 3;
    SampleText("75_Percent", -1, cd%[]);
case MVClevel$ = "100 Percent" then
    cd%[0] := 4;
    SampleText("100_Percent", -1, cd%[]);
endcase;

end;
func MPstim%() 'Points to FindMwave function, but skips muscle dialog
skip%:= 1;
FindMwave%();
skip%:=0;
end;